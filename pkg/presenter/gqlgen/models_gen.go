// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlgen

import (
	"fmt"
	"io"
	"strconv"
)

type BookableOptionSearch interface {
	IsBookableOptionSearch()
}

type Priceable interface {
	IsPriceable()
}

type Response interface {
	IsResponse()
}

type AccessFilterInput struct {
	Includes []string `json:"includes"`
	Excludes []string `json:"excludes"`
}

type AddOn struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type AddOns struct {
	Distribute   *string `json:"distribute"`
	Distribution []AddOn `json:"distribution"`
}

type AuditData struct {
	Transactions []Transactions `json:"transactions"`
	TimeStamp    string         `json:"timeStamp"`
	ProcessTime  float64        `json:"processTime"`
}

type Bed struct {
	Type        *string `json:"type"`
	Description *string `json:"description"`
	Count       *int    `json:"count"`
	Shared      *bool   `json:"shared"`
}

type BusinessRulesInput struct {
	OptionsQuota      *int               `json:"optionsQuota"`
	BusinessRulesType *BusinessRulesType `json:"businessRulesType"`
}

type CancelPenalty struct {
	HoursBefore int               `json:"hoursBefore"`
	PenaltyType CancelPenaltyType `json:"penaltyType"`
	Currency    string            `json:"currency"`
	Value       float64           `json:"value"`
}

type CancelPolicy struct {
	Refundable      bool            `json:"refundable"`
	CancelPenalties []CancelPenalty `json:"cancelPenalties"`
}

type ConfigurationInput struct {
	Username   *string          `json:"username"`
	Password   *string          `json:"password"`
	Urls       UrlsInput        `json:"urls"`
	Parameters []ParameterInput `json:"parameters"`
	Markets    []string         `json:"markets"`
	RateRules  []RateRulesType  `json:"rateRules"`
}

type CriteriaSearch struct {
	CheckIn     string         `json:"checkIn"`
	CheckOut    string         `json:"checkOut"`
	Hotels      []string       `json:"hotels"`
	Occupancies []RoomCriteria `json:"occupancies"`
	Language    *string        `json:"language"`
	Currency    *string        `json:"currency"`
	Nationality *string        `json:"nationality"`
	Market      string         `json:"market"`
}

type Error struct {
	Code        string `json:"code"`
	Type        string `json:"type"`
	Description string `json:"description"`
}

type Exchange struct {
	Currency string  `json:"currency"`
	Rate     float64 `json:"rate"`
}

type FilterInput struct {
	Access    *AccessFilterInput    `json:"access"`
	RateRules *RateRulesFilterInput `json:"rateRules"`
}

type HotelCriteriaSearchInput struct {
	CheckIn      string      `json:"checkIn"`
	CheckOut     string      `json:"checkOut"`
	Hotels       []string    `json:"hotels"`
	Destinations []string    `json:"destinations"`
	Occupancies  []RoomInput `json:"occupancies"`
	Language     *string     `json:"language"`
	Currency     *string     `json:"currency"`
	Nationality  *string     `json:"nationality"`
	Market       *string     `json:"market"`
}

type HotelOptionSearch struct {
	SupplierCode      string          `json:"supplierCode"`
	AccessCode        string          `json:"accessCode"`
	Market            string          `json:"market"`
	HotelCode         string          `json:"hotelCode"`
	HotelCodeSupplier string          `json:"hotelCodeSupplier"`
	HotelName         *string         `json:"hotelName"`
	BoardCode         string          `json:"boardCode"`
	BoardCodeSupplier string          `json:"boardCodeSupplier"`
	PaymentType       PaymentType     `json:"paymentType"`
	Status            StatusType      `json:"status"`
	Occupancies       []Occupancy     `json:"occupancies"`
	Rooms             []Room          `json:"rooms"`
	Price             Price           `json:"price"`
	Supplements       []*Supplement   `json:"supplements"`
	Surcharges        []Surcharge     `json:"surcharges"`
	RateRules         []RateRulesType `json:"rateRules"`
	CancelPolicy      *CancelPolicy   `json:"cancelPolicy"`
	Remarks           *string         `json:"remarks"`
	AddOns            *AddOns         `json:"addOns"`
	Token             string          `json:"token"`
	ID                string          `json:"id"`
}

func (HotelOptionSearch) IsBookableOptionSearch() {}

type HotelSearch struct {
	Context         *string             `json:"context"`
	Stats           *StatsRequest       `json:"stats"`
	AuditData       *AuditData          `json:"auditData"`
	RequestCriteria *CriteriaSearch     `json:"requestCriteria"`
	Options         []HotelOptionSearch `json:"options"`
	Errors          []Error             `json:"errors"`
	Warnings        []Warning           `json:"warnings"`
}

func (HotelSearch) IsResponse() {}

type HotelSettingsInput struct {
	Context           *string               `json:"context"`
	UseContext        *bool                 `json:"useContext"`
	ConnectUser       *string               `json:"connectUser"`
	Client            *string               `json:"client"`
	Group             *string               `json:"group"`
	Timeout           *int                  `json:"timeout"`
	AuditTransactions *bool                 `json:"auditTransactions"`
	BusinessRules     *BusinessRulesInput   `json:"businessRules"`
	Suppliers         []HotelXSupplierInput `json:"suppliers"`
	Plugins           []PluginStepInput     `json:"plugins"`
	TestMode          *bool                 `json:"testMode"`
	ClientTokens      []string              `json:"clientTokens"`
}

type HotelXAccessInput struct {
	AccessID      string              `json:"accessId"`
	Configuration *ConfigurationInput `json:"configuration"`
	Settings      *SettingsBaseInput  `json:"settings"`
}

type HotelXFilterPluginTypeInput struct {
	Step PluginStepType `json:"step"`
	Type string         `json:"type"`
	Name string         `json:"name"`
}

type HotelXFilterSearchInput struct {
	Access    *AccessFilterInput       `json:"access"`
	RateRules *RateRulesFilterInput    `json:"rateRules"`
	Plugin    *HotelXPluginFilterInput `json:"plugin"`
}

type HotelXPluginFilterInput struct {
	Includes []HotelXFilterPluginTypeInput `json:"includes"`
	Excludes []HotelXFilterPluginTypeInput `json:"excludes"`
}

type HotelXQuery struct {
	Search              *HotelSearch  `json:"search"`
	SearchStatusService ServiceStatus `json:"searchStatusService"`
}

type HotelXSupplierInput struct {
	Settings *SettingsBaseInput  `json:"settings"`
	Code     string              `json:"code"`
	Accesses []HotelXAccessInput `json:"accesses"`
}

type Markup struct {
	Channel  *string  `json:"channel"`
	Currency string   `json:"currency"`
	Binding  bool     `json:"binding"`
	Net      float64  `json:"net"`
	Gross    *float64 `json:"gross"`
	Exchange Exchange `json:"exchange"`
	Rules    []Rule   `json:"rules"`
}

func (Markup) IsPriceable() {}

type Occupancy struct {
	ID    int   `json:"id"`
	Paxes []Pax `json:"paxes"`
}

type ParameterInput struct {
	Key   string `json:"key"`
	Value string `json:"value"`
}

type Pax struct {
	Age int `json:"age"`
}

type PaxInput struct {
	Age int `json:"age"`
}

type PluginStepInput struct {
	Step        PluginStepType `json:"step"`
	PluginsType []PluginsInput `json:"pluginsType"`
}

type PluginsInput struct {
	Type       PluginType       `json:"type"`
	Name       string           `json:"name"`
	Parameters []ParameterInput `json:"parameters"`
}

type Price struct {
	Currency string   `json:"currency"`
	Binding  bool     `json:"binding"`
	Net      float64  `json:"net"`
	Gross    *float64 `json:"gross"`
	Exchange Exchange `json:"exchange"`
	Markups  []Markup `json:"markups"`
}

func (Price) IsPriceable() {}

type PriceBreakdown struct {
	EffectiveDate string `json:"effectiveDate"`
	ExpireDate    string `json:"expireDate"`
	Price         Price  `json:"price"`
}

type Promotion struct {
	Code          string  `json:"code"`
	Name          *string `json:"name"`
	EffectiveDate *string `json:"effectiveDate"`
	ExpireDate    *string `json:"expireDate"`
}

type RatePlan struct {
	Code          string  `json:"code"`
	Name          *string `json:"name"`
	EffectiveDate *string `json:"effectiveDate"`
	ExpireDate    *string `json:"expireDate"`
}

type RateRulesFilterInput struct {
	Includes []RateRulesType `json:"includes"`
	Excludes []RateRulesType `json:"excludes"`
}

type Resort struct {
	Code        string  `json:"code"`
	Name        *string `json:"name"`
	Description *string `json:"description"`
}

type Room struct {
	OccupancyRefID int         `json:"occupancyRefId"`
	Code           string      `json:"code"`
	Description    *string     `json:"description"`
	Refundable     *bool       `json:"refundable"`
	Units          *int        `json:"units"`
	RoomPrice      RoomPrice   `json:"roomPrice"`
	Beds           []Bed       `json:"beds"`
	RatePlans      []RatePlan  `json:"ratePlans"`
	Promotions     []Promotion `json:"promotions"`
}

type RoomCriteria struct {
	Paxes []Pax `json:"paxes"`
}

type RoomInput struct {
	Paxes []PaxInput `json:"paxes"`
}

type RoomPrice struct {
	Price     Price            `json:"price"`
	Breakdown []PriceBreakdown `json:"breakdown"`
}

type Rule struct {
	ID    string         `json:"id"`
	Name  *string        `json:"name"`
	Type  MarkupRuleType `json:"type"`
	Value float64        `json:"value"`
}

type Search struct {
	Hotel *HotelSearch `json:"hotel"`
}

type ServiceStatus struct {
	Code        *string `json:"code"`
	Type        *string `json:"type"`
	Description *string `json:"description"`
}

type SettingsBaseInput struct {
	Timeout           *int                `json:"timeout"`
	AuditTransactions *bool               `json:"auditTransactions"`
	BusinessRules     *BusinessRulesInput `json:"businessRules"`
	Currency          *string             `json:"currency"`
}

type Stat struct {
	Start    string   `json:"start"`
	End      string   `json:"end"`
	Duration *float64 `json:"duration"`
}

type StatAccess struct {
	Name                string            `json:"name"`
	Total               Stat              `json:"total"`
	StaticConfiguration *Stat             `json:"staticConfiguration"`
	Hotels              int               `json:"hotels"`
	Zones               int               `json:"zones"`
	Cities              int               `json:"cities"`
	RequestAccess       *StatPlugin       `json:"requestAccess"`
	ResponseAccess      *StatPlugin       `json:"responseAccess"`
	Transactions        []StatTransaction `json:"transactions"`
	Plugins             []StatPlugin      `json:"plugins"`
}

type StatPlugin struct {
	Name  string `json:"name"`
	Total Stat   `json:"total"`
}

type StatTransaction struct {
	Reference           string `json:"reference"`
	Total               Stat   `json:"total"`
	BuildRequest        Stat   `json:"buildRequest"`
	WorkerCommunication Stat   `json:"workerCommunication"`
	ParseResponse       Stat   `json:"parseResponse"`
}

type StatsRequest struct {
	Total          Stat         `json:"total"`
	Validation     Stat         `json:"validation"`
	Process        Stat         `json:"process"`
	Configuration  Stat         `json:"configuration"`
	Request        Stat         `json:"request"`
	Response       Stat         `json:"response"`
	RequestPlugin  *StatPlugin  `json:"requestPlugin"`
	ResponsePlugin *StatPlugin  `json:"responsePlugin"`
	Hotels         int          `json:"hotels"`
	Zones          int          `json:"zones"`
	Cities         int          `json:"cities"`
	DockerID       string       `json:"dockerID"`
	Accesses       []StatAccess `json:"Accesses"`
}

type Supplement struct {
	Code           string         `json:"code"`
	Name           *string        `json:"name"`
	Description    *string        `json:"description"`
	SupplementType SupplementType `json:"supplementType"`
	ChargeType     ChargeType     `json:"chargeType"`
	Mandatory      bool           `json:"mandatory"`
	DurationType   *DurationType  `json:"durationType"`
	Quantity       *int           `json:"quantity"`
	Unit           *UnitTimeType  `json:"unit"`
	EffectiveDate  *string        `json:"effectiveDate"`
	ExpireDate     *string        `json:"expireDate"`
	Resort         *Resort        `json:"resort"`
	Price          *Price         `json:"price"`
}

type Surcharge struct {
	ChargeType  ChargeType `json:"chargeType"`
	Mandatory   bool       `json:"mandatory"`
	Price       Price      `json:"price"`
	Description *string    `json:"description"`
}

type Transactions struct {
	Request   string `json:"request"`
	Response  string `json:"response"`
	TimeStamp string `json:"timeStamp"`
}

type UrlsInput struct {
	Search  *string `json:"search"`
	Quote   *string `json:"quote"`
	Book    *string `json:"book"`
	Generic *string `json:"generic"`
}

type Warning struct {
	Code        string `json:"code"`
	Type        string `json:"type"`
	Description string `json:"description"`
}

type BusinessRulesType string

const (
	BusinessRulesTypeCheaperAmount BusinessRulesType = "CHEAPER_AMOUNT"
	BusinessRulesTypeRoomType      BusinessRulesType = "ROOM_TYPE"
)

var AllBusinessRulesType = []BusinessRulesType{
	BusinessRulesTypeCheaperAmount,
	BusinessRulesTypeRoomType,
}

func (e BusinessRulesType) IsValid() bool {
	switch e {
	case BusinessRulesTypeCheaperAmount, BusinessRulesTypeRoomType:
		return true
	}
	return false
}

func (e BusinessRulesType) String() string {
	return string(e)
}

func (e *BusinessRulesType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BusinessRulesType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BusinessRulesType", str)
	}
	return nil
}

func (e BusinessRulesType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CancelPenaltyType string

const (
	CancelPenaltyTypeNights  CancelPenaltyType = "NIGHTS"
	CancelPenaltyTypePercent CancelPenaltyType = "PERCENT"
	CancelPenaltyTypeImport  CancelPenaltyType = "IMPORT"
)

var AllCancelPenaltyType = []CancelPenaltyType{
	CancelPenaltyTypeNights,
	CancelPenaltyTypePercent,
	CancelPenaltyTypeImport,
}

func (e CancelPenaltyType) IsValid() bool {
	switch e {
	case CancelPenaltyTypeNights, CancelPenaltyTypePercent, CancelPenaltyTypeImport:
		return true
	}
	return false
}

func (e CancelPenaltyType) String() string {
	return string(e)
}

func (e *CancelPenaltyType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CancelPenaltyType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CancelPenaltyType", str)
	}
	return nil
}

func (e CancelPenaltyType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ChargeType string

const (
	ChargeTypeInclude ChargeType = "INCLUDE"
	ChargeTypeExclude ChargeType = "EXCLUDE"
)

var AllChargeType = []ChargeType{
	ChargeTypeInclude,
	ChargeTypeExclude,
}

func (e ChargeType) IsValid() bool {
	switch e {
	case ChargeTypeInclude, ChargeTypeExclude:
		return true
	}
	return false
}

func (e ChargeType) String() string {
	return string(e)
}

func (e *ChargeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChargeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChargeType", str)
	}
	return nil
}

func (e ChargeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DurationType string

const (
	DurationTypeRange DurationType = "RANGE"
	DurationTypeOpen  DurationType = "OPEN"
)

var AllDurationType = []DurationType{
	DurationTypeRange,
	DurationTypeOpen,
}

func (e DurationType) IsValid() bool {
	switch e {
	case DurationTypeRange, DurationTypeOpen:
		return true
	}
	return false
}

func (e DurationType) String() string {
	return string(e)
}

func (e *DurationType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DurationType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DurationType", str)
	}
	return nil
}

func (e DurationType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MarkupRuleType string

const (
	MarkupRuleTypePercent MarkupRuleType = "PERCENT"
	MarkupRuleTypeImport  MarkupRuleType = "IMPORT"
)

var AllMarkupRuleType = []MarkupRuleType{
	MarkupRuleTypePercent,
	MarkupRuleTypeImport,
}

func (e MarkupRuleType) IsValid() bool {
	switch e {
	case MarkupRuleTypePercent, MarkupRuleTypeImport:
		return true
	}
	return false
}

func (e MarkupRuleType) String() string {
	return string(e)
}

func (e *MarkupRuleType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MarkupRuleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MarkupRuleType", str)
	}
	return nil
}

func (e MarkupRuleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PaymentType string

const (
	PaymentTypeMerchant    PaymentType = "MERCHANT"
	PaymentTypeDirect      PaymentType = "DIRECT"
	PaymentTypeCardBooking PaymentType = "CARD_BOOKING"
	PaymentTypeCardCheckIn PaymentType = "CARD_CHECK_IN"
)

var AllPaymentType = []PaymentType{
	PaymentTypeMerchant,
	PaymentTypeDirect,
	PaymentTypeCardBooking,
	PaymentTypeCardCheckIn,
}

func (e PaymentType) IsValid() bool {
	switch e {
	case PaymentTypeMerchant, PaymentTypeDirect, PaymentTypeCardBooking, PaymentTypeCardCheckIn:
		return true
	}
	return false
}

func (e PaymentType) String() string {
	return string(e)
}

func (e *PaymentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PaymentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PaymentType", str)
	}
	return nil
}

func (e PaymentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PluginStepType string

const (
	PluginStepTypeRequest        PluginStepType = "REQUEST"
	PluginStepTypeRequestAccess  PluginStepType = "REQUEST_ACCESS"
	PluginStepTypeResponseOption PluginStepType = "RESPONSE_OPTION"
	PluginStepTypeResponseAccess PluginStepType = "RESPONSE_ACCESS"
	PluginStepTypeResponse       PluginStepType = "RESPONSE"
)

var AllPluginStepType = []PluginStepType{
	PluginStepTypeRequest,
	PluginStepTypeRequestAccess,
	PluginStepTypeResponseOption,
	PluginStepTypeResponseAccess,
	PluginStepTypeResponse,
}

func (e PluginStepType) IsValid() bool {
	switch e {
	case PluginStepTypeRequest, PluginStepTypeRequestAccess, PluginStepTypeResponseOption, PluginStepTypeResponseAccess, PluginStepTypeResponse:
		return true
	}
	return false
}

func (e PluginStepType) String() string {
	return string(e)
}

func (e *PluginStepType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PluginStepType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PluginStepType", str)
	}
	return nil
}

func (e PluginStepType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PluginType string

const (
	PluginTypePreStep            PluginType = "PRE_STEP"
	PluginTypeHotelMap           PluginType = "HOTEL_MAP"
	PluginTypeBoardMap           PluginType = "BOARD_MAP"
	PluginTypeRoomMap            PluginType = "ROOM_MAP"
	PluginTypeCurrencyConversion PluginType = "CURRENCY_CONVERSION"
	PluginTypeMarkup             PluginType = "MARKUP"
	PluginTypeAggregation        PluginType = "AGGREGATION"
	PluginTypePostStep           PluginType = "POST_STEP"
)

var AllPluginType = []PluginType{
	PluginTypePreStep,
	PluginTypeHotelMap,
	PluginTypeBoardMap,
	PluginTypeRoomMap,
	PluginTypeCurrencyConversion,
	PluginTypeMarkup,
	PluginTypeAggregation,
	PluginTypePostStep,
}

func (e PluginType) IsValid() bool {
	switch e {
	case PluginTypePreStep, PluginTypeHotelMap, PluginTypeBoardMap, PluginTypeRoomMap, PluginTypeCurrencyConversion, PluginTypeMarkup, PluginTypeAggregation, PluginTypePostStep:
		return true
	}
	return false
}

func (e PluginType) String() string {
	return string(e)
}

func (e *PluginType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PluginType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PluginType", str)
	}
	return nil
}

func (e PluginType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PriceType string

const (
	PriceTypeGross  PriceType = "GROSS"
	PriceTypeNet    PriceType = "NET"
	PriceTypeAmount PriceType = "AMOUNT"
)

var AllPriceType = []PriceType{
	PriceTypeGross,
	PriceTypeNet,
	PriceTypeAmount,
}

func (e PriceType) IsValid() bool {
	switch e {
	case PriceTypeGross, PriceTypeNet, PriceTypeAmount:
		return true
	}
	return false
}

func (e PriceType) String() string {
	return string(e)
}

func (e *PriceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PriceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PriceType", str)
	}
	return nil
}

func (e PriceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RateRulesType string

const (
	RateRulesTypePackage          RateRulesType = "PACKAGE"
	RateRulesTypeOlder55          RateRulesType = "OLDER55"
	RateRulesTypeOlder60          RateRulesType = "OLDER60"
	RateRulesTypeOlder65          RateRulesType = "OLDER65"
	RateRulesTypeCanaryResident   RateRulesType = "CANARY_RESIDENT"
	RateRulesTypeBalearicResident RateRulesType = "BALEARIC_RESIDENT"
	RateRulesTypeLargeFamily      RateRulesType = "LARGE_FAMILY"
	RateRulesTypeHoneymoon        RateRulesType = "HONEYMOON"
	RateRulesTypePublicServant    RateRulesType = "PUBLIC_SERVANT"
	RateRulesTypeUnemployed       RateRulesType = "UNEMPLOYED"
	RateRulesTypeNormal           RateRulesType = "NORMAL"
	RateRulesTypeNonRefundable    RateRulesType = "NON_REFUNDABLE"
)

var AllRateRulesType = []RateRulesType{
	RateRulesTypePackage,
	RateRulesTypeOlder55,
	RateRulesTypeOlder60,
	RateRulesTypeOlder65,
	RateRulesTypeCanaryResident,
	RateRulesTypeBalearicResident,
	RateRulesTypeLargeFamily,
	RateRulesTypeHoneymoon,
	RateRulesTypePublicServant,
	RateRulesTypeUnemployed,
	RateRulesTypeNormal,
	RateRulesTypeNonRefundable,
}

func (e RateRulesType) IsValid() bool {
	switch e {
	case RateRulesTypePackage, RateRulesTypeOlder55, RateRulesTypeOlder60, RateRulesTypeOlder65, RateRulesTypeCanaryResident, RateRulesTypeBalearicResident, RateRulesTypeLargeFamily, RateRulesTypeHoneymoon, RateRulesTypePublicServant, RateRulesTypeUnemployed, RateRulesTypeNormal, RateRulesTypeNonRefundable:
		return true
	}
	return false
}

func (e RateRulesType) String() string {
	return string(e)
}

func (e *RateRulesType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RateRulesType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RateRulesType", str)
	}
	return nil
}

func (e RateRulesType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ServiceType string

const (
	ServiceTypeSkiPass ServiceType = "SKI_PASS"
)

var AllServiceType = []ServiceType{
	ServiceTypeSkiPass,
}

func (e ServiceType) IsValid() bool {
	switch e {
	case ServiceTypeSkiPass:
		return true
	}
	return false
}

func (e ServiceType) String() string {
	return string(e)
}

func (e *ServiceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceType", str)
	}
	return nil
}

func (e ServiceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type StatusType string

const (
	StatusTypeOk StatusType = "OK"
	StatusTypeRq StatusType = "RQ"
)

var AllStatusType = []StatusType{
	StatusTypeOk,
	StatusTypeRq,
}

func (e StatusType) IsValid() bool {
	switch e {
	case StatusTypeOk, StatusTypeRq:
		return true
	}
	return false
}

func (e StatusType) String() string {
	return string(e)
}

func (e *StatusType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = StatusType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid StatusType", str)
	}
	return nil
}

func (e StatusType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SupplementType string

const (
	SupplementTypeSkiPass   SupplementType = "SKI_PASS"
	SupplementTypeLessons   SupplementType = "LESSONS"
	SupplementTypeMeals     SupplementType = "MEALS"
	SupplementTypeEquipment SupplementType = "EQUIPMENT"
	SupplementTypeTicket    SupplementType = "TICKET"
	SupplementTypeTransfers SupplementType = "TRANSFERS"
	SupplementTypeGala      SupplementType = "GALA"
	SupplementTypeActivity  SupplementType = "ACTIVITY"
)

var AllSupplementType = []SupplementType{
	SupplementTypeSkiPass,
	SupplementTypeLessons,
	SupplementTypeMeals,
	SupplementTypeEquipment,
	SupplementTypeTicket,
	SupplementTypeTransfers,
	SupplementTypeGala,
	SupplementTypeActivity,
}

func (e SupplementType) IsValid() bool {
	switch e {
	case SupplementTypeSkiPass, SupplementTypeLessons, SupplementTypeMeals, SupplementTypeEquipment, SupplementTypeTicket, SupplementTypeTransfers, SupplementTypeGala, SupplementTypeActivity:
		return true
	}
	return false
}

func (e SupplementType) String() string {
	return string(e)
}

func (e *SupplementType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SupplementType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SupplementType", str)
	}
	return nil
}

func (e SupplementType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UnitTimeType string

const (
	UnitTimeTypeDay  UnitTimeType = "DAY"
	UnitTimeTypeHour UnitTimeType = "HOUR"
)

var AllUnitTimeType = []UnitTimeType{
	UnitTimeTypeDay,
	UnitTimeTypeHour,
}

func (e UnitTimeType) IsValid() bool {
	switch e {
	case UnitTimeTypeDay, UnitTimeTypeHour:
		return true
	}
	return false
}

func (e UnitTimeType) String() string {
	return string(e)
}

func (e *UnitTimeType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UnitTimeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UnitTimeType", str)
	}
	return nil
}

func (e UnitTimeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
