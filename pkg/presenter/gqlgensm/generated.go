// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlgensm

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/travelgateX/presenters-benchmark/pkg/access"
	"github.com/travelgateX/presenters-benchmark/pkg/common"
	"github.com/travelgateX/presenters-benchmark/pkg/domainHotelCommon"
	"github.com/travelgateX/presenters-benchmark/pkg/search"
	"github.com/vektah/gqlparser"
	"github.com/vektah/gqlparser/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	HotelOptionSearch() HotelOptionSearchResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AddOn struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	AddOns struct {
		Distribute   func(childComplexity int) int
		Distribution func(childComplexity int) int
	}

	AuditData struct {
		ProcessTime  func(childComplexity int) int
		TimeStamp    func(childComplexity int) int
		Transactions func(childComplexity int) int
	}

	Bed struct {
		Count       func(childComplexity int) int
		Description func(childComplexity int) int
		Shared      func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	CancelPenalty struct {
		Currency    func(childComplexity int) int
		HoursBefore func(childComplexity int) int
		Type        func(childComplexity int) int
		Value       func(childComplexity int) int
	}

	CancelPolicy struct {
		CancelPenalties func(childComplexity int) int
		Refundable      func(childComplexity int) int
	}

	CriteriaSearch struct {
		CheckIn     func(childComplexity int) int
		CheckOut    func(childComplexity int) int
		Currency    func(childComplexity int) int
		Hotels      func(childComplexity int) int
		Language    func(childComplexity int) int
		Market      func(childComplexity int) int
		Nationality func(childComplexity int) int
		Occupancies func(childComplexity int) int
	}

	Error struct {
		Code        func(childComplexity int) int
		Description func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	Exchange struct {
		Currency func(childComplexity int) int
		Rate     func(childComplexity int) int
	}

	HotelOptionSearch struct {
		Access            func(childComplexity int) int
		AddOns            func(childComplexity int) int
		BoardCode         func(childComplexity int) int
		BoardCodeOriginal func(childComplexity int) int
		CancelPolicy      func(childComplexity int) int
		HotelCode         func(childComplexity int) int
		HotelCodeSupplier func(childComplexity int) int
		HotelName         func(childComplexity int) int
		Market            func(childComplexity int) int
		Occupancies       func(childComplexity int) int
		OptionID          func(childComplexity int) int
		PaymentType       func(childComplexity int) int
		Price             func(childComplexity int) int
		RateRules         func(childComplexity int) int
		Remarks           func(childComplexity int) int
		Rooms             func(childComplexity int) int
		Status            func(childComplexity int) int
		Supplements       func(childComplexity int) int
		Supplier          func(childComplexity int) int
		Surcharges        func(childComplexity int) int
		Token             func(childComplexity int) int
	}

	HotelSearch struct {
		AuditData       func(childComplexity int) int
		Context         func(childComplexity int) int
		Errors          func(childComplexity int) int
		Options         func(childComplexity int) int
		RequestCriteria func(childComplexity int) int
		Stats           func(childComplexity int, token string) int
		Warnings        func(childComplexity int) int
	}

	HotelXQuery struct {
		Search              func(childComplexity int) int
		SearchStatusService func(childComplexity int) int
	}

	Markup struct {
		Binding  func(childComplexity int) int
		Channel  func(childComplexity int) int
		Currency func(childComplexity int) int
		Exchange func(childComplexity int) int
		Gross    func(childComplexity int) int
		Net      func(childComplexity int) int
		Rules    func(childComplexity int) int
	}

	Occupancy struct {
		Id    func(childComplexity int) int
		Paxes func(childComplexity int) int
	}

	Pax struct {
		Age func(childComplexity int) int
	}

	Price struct {
		Binding  func(childComplexity int) int
		Currency func(childComplexity int) int
		Exchange func(childComplexity int) int
		Gross    func(childComplexity int) int
		Markups  func(childComplexity int) int
		Net      func(childComplexity int) int
	}

	PriceBreakdown struct {
		EffectiveDate func(childComplexity int) int
		ExpireDate    func(childComplexity int) int
		Price         func(childComplexity int) int
	}

	Promotion struct {
		Code          func(childComplexity int) int
		EffectiveDate func(childComplexity int) int
		ExpireDate    func(childComplexity int) int
		Name          func(childComplexity int) int
	}

	Query struct {
		HotelX func(childComplexity int) int
	}

	RatePlan struct {
		Code          func(childComplexity int) int
		EffectiveDate func(childComplexity int) int
		ExpireDate    func(childComplexity int) int
		Name          func(childComplexity int) int
	}

	Resort struct {
		Code        func(childComplexity int) int
		Description func(childComplexity int) int
		Name        func(childComplexity int) int
	}

	Room struct {
		Beds           func(childComplexity int) int
		Code           func(childComplexity int) int
		Description    func(childComplexity int) int
		OccupancyRefID func(childComplexity int) int
		Promotions     func(childComplexity int) int
		RatePlans      func(childComplexity int) int
		Refundable     func(childComplexity int) int
		RoomPrice      func(childComplexity int) int
		Units          func(childComplexity int) int
	}

	RoomCriteria struct {
		Paxes func(childComplexity int) int
	}

	RoomPrice struct {
		Breakdown func(childComplexity int) int
		Price     func(childComplexity int) int
	}

	Rule struct {
		Id    func(childComplexity int) int
		Name  func(childComplexity int) int
		Type  func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Search struct {
		Hotel func(childComplexity int, token *string, criteria *HotelCriteriaSearchInput, settings *domainHotelCommon.Settings, filter *search.Filter) int
	}

	ServiceStatus struct {
		Code        func(childComplexity int) int
		Description func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	Stat struct {
		Duration func(childComplexity int) int
		End      func(childComplexity int) int
		Start    func(childComplexity int) int
	}

	StatAccess struct {
		Cities              func(childComplexity int) int
		Hotels              func(childComplexity int) int
		Name                func(childComplexity int) int
		Plugins             func(childComplexity int) int
		RequestAccess       func(childComplexity int) int
		ResponseAccess      func(childComplexity int) int
		StaticConfiguration func(childComplexity int) int
		Total               func(childComplexity int) int
		Transactions        func(childComplexity int) int
		Zones               func(childComplexity int) int
	}

	StatPlugin struct {
		Name  func(childComplexity int) int
		Total func(childComplexity int) int
	}

	StatTransaction struct {
		BuildRequest        func(childComplexity int) int
		ParseResponse       func(childComplexity int) int
		Reference           func(childComplexity int) int
		Total               func(childComplexity int) int
		WorkerCommunication func(childComplexity int) int
	}

	StatsRequest struct {
		Accesses       func(childComplexity int) int
		Cities         func(childComplexity int) int
		Configuration  func(childComplexity int) int
		DockerID       func(childComplexity int) int
		Hotels         func(childComplexity int) int
		Process        func(childComplexity int) int
		Request        func(childComplexity int) int
		RequestPlugin  func(childComplexity int) int
		Response       func(childComplexity int) int
		ResponsePlugin func(childComplexity int) int
		Total          func(childComplexity int) int
		Validation     func(childComplexity int) int
		Zones          func(childComplexity int) int
	}

	Supplement struct {
		ChargeType     func(childComplexity int) int
		Code           func(childComplexity int) int
		Description    func(childComplexity int) int
		DurationType   func(childComplexity int) int
		EffectiveDate  func(childComplexity int) int
		ExpireDate     func(childComplexity int) int
		Mandatory      func(childComplexity int) int
		Name           func(childComplexity int) int
		Price          func(childComplexity int) int
		Quantity       func(childComplexity int) int
		Resort         func(childComplexity int) int
		SupplementType func(childComplexity int) int
		Unit           func(childComplexity int) int
	}

	Surcharge struct {
		ChargeType  func(childComplexity int) int
		Description func(childComplexity int) int
		Mandatory   func(childComplexity int) int
		Price       func(childComplexity int) int
	}

	Transactions struct {
		Request   func(childComplexity int) int
		Response  func(childComplexity int) int
		TimeStamp func(childComplexity int) int
	}

	Warning struct {
		Code        func(childComplexity int) int
		Description func(childComplexity int) int
		Type        func(childComplexity int) int
	}
}

type HotelOptionSearchResolver interface {
	RateRules(ctx context.Context, obj *domainHotelCommon.Option) ([]RateRulesType, error)

	AddOns(ctx context.Context, obj *domainHotelCommon.Option) (*AddOns, error)
}
type QueryResolver interface {
	HotelX(ctx context.Context) (*HotelXQuery, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "AddOn.Key":
		if e.complexity.AddOn.Key == nil {
			break
		}

		return e.complexity.AddOn.Key(childComplexity), true

	case "AddOn.Value":
		if e.complexity.AddOn.Value == nil {
			break
		}

		return e.complexity.AddOn.Value(childComplexity), true

	case "AddOns.Distribute":
		if e.complexity.AddOns.Distribute == nil {
			break
		}

		return e.complexity.AddOns.Distribute(childComplexity), true

	case "AddOns.Distribution":
		if e.complexity.AddOns.Distribution == nil {
			break
		}

		return e.complexity.AddOns.Distribution(childComplexity), true

	case "AuditData.ProcessTime":
		if e.complexity.AuditData.ProcessTime == nil {
			break
		}

		return e.complexity.AuditData.ProcessTime(childComplexity), true

	case "AuditData.TimeStamp":
		if e.complexity.AuditData.TimeStamp == nil {
			break
		}

		return e.complexity.AuditData.TimeStamp(childComplexity), true

	case "AuditData.Transactions":
		if e.complexity.AuditData.Transactions == nil {
			break
		}

		return e.complexity.AuditData.Transactions(childComplexity), true

	case "Bed.Count":
		if e.complexity.Bed.Count == nil {
			break
		}

		return e.complexity.Bed.Count(childComplexity), true

	case "Bed.Description":
		if e.complexity.Bed.Description == nil {
			break
		}

		return e.complexity.Bed.Description(childComplexity), true

	case "Bed.Shared":
		if e.complexity.Bed.Shared == nil {
			break
		}

		return e.complexity.Bed.Shared(childComplexity), true

	case "Bed.Type":
		if e.complexity.Bed.Type == nil {
			break
		}

		return e.complexity.Bed.Type(childComplexity), true

	case "CancelPenalty.Currency":
		if e.complexity.CancelPenalty.Currency == nil {
			break
		}

		return e.complexity.CancelPenalty.Currency(childComplexity), true

	case "CancelPenalty.HoursBefore":
		if e.complexity.CancelPenalty.HoursBefore == nil {
			break
		}

		return e.complexity.CancelPenalty.HoursBefore(childComplexity), true

	case "CancelPenalty.Type":
		if e.complexity.CancelPenalty.Type == nil {
			break
		}

		return e.complexity.CancelPenalty.Type(childComplexity), true

	case "CancelPenalty.Value":
		if e.complexity.CancelPenalty.Value == nil {
			break
		}

		return e.complexity.CancelPenalty.Value(childComplexity), true

	case "CancelPolicy.CancelPenalties":
		if e.complexity.CancelPolicy.CancelPenalties == nil {
			break
		}

		return e.complexity.CancelPolicy.CancelPenalties(childComplexity), true

	case "CancelPolicy.Refundable":
		if e.complexity.CancelPolicy.Refundable == nil {
			break
		}

		return e.complexity.CancelPolicy.Refundable(childComplexity), true

	case "CriteriaSearch.CheckIn":
		if e.complexity.CriteriaSearch.CheckIn == nil {
			break
		}

		return e.complexity.CriteriaSearch.CheckIn(childComplexity), true

	case "CriteriaSearch.CheckOut":
		if e.complexity.CriteriaSearch.CheckOut == nil {
			break
		}

		return e.complexity.CriteriaSearch.CheckOut(childComplexity), true

	case "CriteriaSearch.Currency":
		if e.complexity.CriteriaSearch.Currency == nil {
			break
		}

		return e.complexity.CriteriaSearch.Currency(childComplexity), true

	case "CriteriaSearch.Hotels":
		if e.complexity.CriteriaSearch.Hotels == nil {
			break
		}

		return e.complexity.CriteriaSearch.Hotels(childComplexity), true

	case "CriteriaSearch.Language":
		if e.complexity.CriteriaSearch.Language == nil {
			break
		}

		return e.complexity.CriteriaSearch.Language(childComplexity), true

	case "CriteriaSearch.Market":
		if e.complexity.CriteriaSearch.Market == nil {
			break
		}

		return e.complexity.CriteriaSearch.Market(childComplexity), true

	case "CriteriaSearch.Nationality":
		if e.complexity.CriteriaSearch.Nationality == nil {
			break
		}

		return e.complexity.CriteriaSearch.Nationality(childComplexity), true

	case "CriteriaSearch.Occupancies":
		if e.complexity.CriteriaSearch.Occupancies == nil {
			break
		}

		return e.complexity.CriteriaSearch.Occupancies(childComplexity), true

	case "Error.Code":
		if e.complexity.Error.Code == nil {
			break
		}

		return e.complexity.Error.Code(childComplexity), true

	case "Error.Description":
		if e.complexity.Error.Description == nil {
			break
		}

		return e.complexity.Error.Description(childComplexity), true

	case "Error.Type":
		if e.complexity.Error.Type == nil {
			break
		}

		return e.complexity.Error.Type(childComplexity), true

	case "Exchange.Currency":
		if e.complexity.Exchange.Currency == nil {
			break
		}

		return e.complexity.Exchange.Currency(childComplexity), true

	case "Exchange.Rate":
		if e.complexity.Exchange.Rate == nil {
			break
		}

		return e.complexity.Exchange.Rate(childComplexity), true

	case "HotelOptionSearch.Access":
		if e.complexity.HotelOptionSearch.Access == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Access(childComplexity), true

	case "HotelOptionSearch.AddOns":
		if e.complexity.HotelOptionSearch.AddOns == nil {
			break
		}

		return e.complexity.HotelOptionSearch.AddOns(childComplexity), true

	case "HotelOptionSearch.BoardCode":
		if e.complexity.HotelOptionSearch.BoardCode == nil {
			break
		}

		return e.complexity.HotelOptionSearch.BoardCode(childComplexity), true

	case "HotelOptionSearch.BoardCodeOriginal":
		if e.complexity.HotelOptionSearch.BoardCodeOriginal == nil {
			break
		}

		return e.complexity.HotelOptionSearch.BoardCodeOriginal(childComplexity), true

	case "HotelOptionSearch.CancelPolicy":
		if e.complexity.HotelOptionSearch.CancelPolicy == nil {
			break
		}

		return e.complexity.HotelOptionSearch.CancelPolicy(childComplexity), true

	case "HotelOptionSearch.HotelCode":
		if e.complexity.HotelOptionSearch.HotelCode == nil {
			break
		}

		return e.complexity.HotelOptionSearch.HotelCode(childComplexity), true

	case "HotelOptionSearch.HotelCodeSupplier":
		if e.complexity.HotelOptionSearch.HotelCodeSupplier == nil {
			break
		}

		return e.complexity.HotelOptionSearch.HotelCodeSupplier(childComplexity), true

	case "HotelOptionSearch.HotelName":
		if e.complexity.HotelOptionSearch.HotelName == nil {
			break
		}

		return e.complexity.HotelOptionSearch.HotelName(childComplexity), true

	case "HotelOptionSearch.Market":
		if e.complexity.HotelOptionSearch.Market == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Market(childComplexity), true

	case "HotelOptionSearch.Occupancies":
		if e.complexity.HotelOptionSearch.Occupancies == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Occupancies(childComplexity), true

	case "HotelOptionSearch.OptionID":
		if e.complexity.HotelOptionSearch.OptionID == nil {
			break
		}

		return e.complexity.HotelOptionSearch.OptionID(childComplexity), true

	case "HotelOptionSearch.PaymentType":
		if e.complexity.HotelOptionSearch.PaymentType == nil {
			break
		}

		return e.complexity.HotelOptionSearch.PaymentType(childComplexity), true

	case "HotelOptionSearch.Price":
		if e.complexity.HotelOptionSearch.Price == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Price(childComplexity), true

	case "HotelOptionSearch.RateRules":
		if e.complexity.HotelOptionSearch.RateRules == nil {
			break
		}

		return e.complexity.HotelOptionSearch.RateRules(childComplexity), true

	case "HotelOptionSearch.Remarks":
		if e.complexity.HotelOptionSearch.Remarks == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Remarks(childComplexity), true

	case "HotelOptionSearch.Rooms":
		if e.complexity.HotelOptionSearch.Rooms == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Rooms(childComplexity), true

	case "HotelOptionSearch.Status":
		if e.complexity.HotelOptionSearch.Status == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Status(childComplexity), true

	case "HotelOptionSearch.Supplements":
		if e.complexity.HotelOptionSearch.Supplements == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Supplements(childComplexity), true

	case "HotelOptionSearch.Supplier":
		if e.complexity.HotelOptionSearch.Supplier == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Supplier(childComplexity), true

	case "HotelOptionSearch.Surcharges":
		if e.complexity.HotelOptionSearch.Surcharges == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Surcharges(childComplexity), true

	case "HotelOptionSearch.Token":
		if e.complexity.HotelOptionSearch.Token == nil {
			break
		}

		return e.complexity.HotelOptionSearch.Token(childComplexity), true

	case "HotelSearch.AuditData":
		if e.complexity.HotelSearch.AuditData == nil {
			break
		}

		return e.complexity.HotelSearch.AuditData(childComplexity), true

	case "HotelSearch.Context":
		if e.complexity.HotelSearch.Context == nil {
			break
		}

		return e.complexity.HotelSearch.Context(childComplexity), true

	case "HotelSearch.Errors":
		if e.complexity.HotelSearch.Errors == nil {
			break
		}

		return e.complexity.HotelSearch.Errors(childComplexity), true

	case "HotelSearch.Options":
		if e.complexity.HotelSearch.Options == nil {
			break
		}

		return e.complexity.HotelSearch.Options(childComplexity), true

	case "HotelSearch.RequestCriteria":
		if e.complexity.HotelSearch.RequestCriteria == nil {
			break
		}

		return e.complexity.HotelSearch.RequestCriteria(childComplexity), true

	case "HotelSearch.Stats":
		if e.complexity.HotelSearch.Stats == nil {
			break
		}

		args, err := ec.field_HotelSearch_stats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.HotelSearch.Stats(childComplexity, args["token"].(string)), true

	case "HotelSearch.Warnings":
		if e.complexity.HotelSearch.Warnings == nil {
			break
		}

		return e.complexity.HotelSearch.Warnings(childComplexity), true

	case "HotelXQuery.Search":
		if e.complexity.HotelXQuery.Search == nil {
			break
		}

		return e.complexity.HotelXQuery.Search(childComplexity), true

	case "HotelXQuery.SearchStatusService":
		if e.complexity.HotelXQuery.SearchStatusService == nil {
			break
		}

		return e.complexity.HotelXQuery.SearchStatusService(childComplexity), true

	case "Markup.Binding":
		if e.complexity.Markup.Binding == nil {
			break
		}

		return e.complexity.Markup.Binding(childComplexity), true

	case "Markup.Channel":
		if e.complexity.Markup.Channel == nil {
			break
		}

		return e.complexity.Markup.Channel(childComplexity), true

	case "Markup.Currency":
		if e.complexity.Markup.Currency == nil {
			break
		}

		return e.complexity.Markup.Currency(childComplexity), true

	case "Markup.Exchange":
		if e.complexity.Markup.Exchange == nil {
			break
		}

		return e.complexity.Markup.Exchange(childComplexity), true

	case "Markup.Gross":
		if e.complexity.Markup.Gross == nil {
			break
		}

		return e.complexity.Markup.Gross(childComplexity), true

	case "Markup.Net":
		if e.complexity.Markup.Net == nil {
			break
		}

		return e.complexity.Markup.Net(childComplexity), true

	case "Markup.Rules":
		if e.complexity.Markup.Rules == nil {
			break
		}

		return e.complexity.Markup.Rules(childComplexity), true

	case "Occupancy.Id":
		if e.complexity.Occupancy.Id == nil {
			break
		}

		return e.complexity.Occupancy.Id(childComplexity), true

	case "Occupancy.Paxes":
		if e.complexity.Occupancy.Paxes == nil {
			break
		}

		return e.complexity.Occupancy.Paxes(childComplexity), true

	case "Pax.Age":
		if e.complexity.Pax.Age == nil {
			break
		}

		return e.complexity.Pax.Age(childComplexity), true

	case "Price.Binding":
		if e.complexity.Price.Binding == nil {
			break
		}

		return e.complexity.Price.Binding(childComplexity), true

	case "Price.Currency":
		if e.complexity.Price.Currency == nil {
			break
		}

		return e.complexity.Price.Currency(childComplexity), true

	case "Price.Exchange":
		if e.complexity.Price.Exchange == nil {
			break
		}

		return e.complexity.Price.Exchange(childComplexity), true

	case "Price.Gross":
		if e.complexity.Price.Gross == nil {
			break
		}

		return e.complexity.Price.Gross(childComplexity), true

	case "Price.Markups":
		if e.complexity.Price.Markups == nil {
			break
		}

		return e.complexity.Price.Markups(childComplexity), true

	case "Price.Net":
		if e.complexity.Price.Net == nil {
			break
		}

		return e.complexity.Price.Net(childComplexity), true

	case "PriceBreakdown.EffectiveDate":
		if e.complexity.PriceBreakdown.EffectiveDate == nil {
			break
		}

		return e.complexity.PriceBreakdown.EffectiveDate(childComplexity), true

	case "PriceBreakdown.ExpireDate":
		if e.complexity.PriceBreakdown.ExpireDate == nil {
			break
		}

		return e.complexity.PriceBreakdown.ExpireDate(childComplexity), true

	case "PriceBreakdown.Price":
		if e.complexity.PriceBreakdown.Price == nil {
			break
		}

		return e.complexity.PriceBreakdown.Price(childComplexity), true

	case "Promotion.Code":
		if e.complexity.Promotion.Code == nil {
			break
		}

		return e.complexity.Promotion.Code(childComplexity), true

	case "Promotion.EffectiveDate":
		if e.complexity.Promotion.EffectiveDate == nil {
			break
		}

		return e.complexity.Promotion.EffectiveDate(childComplexity), true

	case "Promotion.ExpireDate":
		if e.complexity.Promotion.ExpireDate == nil {
			break
		}

		return e.complexity.Promotion.ExpireDate(childComplexity), true

	case "Promotion.Name":
		if e.complexity.Promotion.Name == nil {
			break
		}

		return e.complexity.Promotion.Name(childComplexity), true

	case "Query.HotelX":
		if e.complexity.Query.HotelX == nil {
			break
		}

		return e.complexity.Query.HotelX(childComplexity), true

	case "RatePlan.Code":
		if e.complexity.RatePlan.Code == nil {
			break
		}

		return e.complexity.RatePlan.Code(childComplexity), true

	case "RatePlan.EffectiveDate":
		if e.complexity.RatePlan.EffectiveDate == nil {
			break
		}

		return e.complexity.RatePlan.EffectiveDate(childComplexity), true

	case "RatePlan.ExpireDate":
		if e.complexity.RatePlan.ExpireDate == nil {
			break
		}

		return e.complexity.RatePlan.ExpireDate(childComplexity), true

	case "RatePlan.Name":
		if e.complexity.RatePlan.Name == nil {
			break
		}

		return e.complexity.RatePlan.Name(childComplexity), true

	case "Resort.Code":
		if e.complexity.Resort.Code == nil {
			break
		}

		return e.complexity.Resort.Code(childComplexity), true

	case "Resort.Description":
		if e.complexity.Resort.Description == nil {
			break
		}

		return e.complexity.Resort.Description(childComplexity), true

	case "Resort.Name":
		if e.complexity.Resort.Name == nil {
			break
		}

		return e.complexity.Resort.Name(childComplexity), true

	case "Room.Beds":
		if e.complexity.Room.Beds == nil {
			break
		}

		return e.complexity.Room.Beds(childComplexity), true

	case "Room.Code":
		if e.complexity.Room.Code == nil {
			break
		}

		return e.complexity.Room.Code(childComplexity), true

	case "Room.Description":
		if e.complexity.Room.Description == nil {
			break
		}

		return e.complexity.Room.Description(childComplexity), true

	case "Room.OccupancyRefID":
		if e.complexity.Room.OccupancyRefID == nil {
			break
		}

		return e.complexity.Room.OccupancyRefID(childComplexity), true

	case "Room.Promotions":
		if e.complexity.Room.Promotions == nil {
			break
		}

		return e.complexity.Room.Promotions(childComplexity), true

	case "Room.RatePlans":
		if e.complexity.Room.RatePlans == nil {
			break
		}

		return e.complexity.Room.RatePlans(childComplexity), true

	case "Room.Refundable":
		if e.complexity.Room.Refundable == nil {
			break
		}

		return e.complexity.Room.Refundable(childComplexity), true

	case "Room.RoomPrice":
		if e.complexity.Room.RoomPrice == nil {
			break
		}

		return e.complexity.Room.RoomPrice(childComplexity), true

	case "Room.Units":
		if e.complexity.Room.Units == nil {
			break
		}

		return e.complexity.Room.Units(childComplexity), true

	case "RoomCriteria.Paxes":
		if e.complexity.RoomCriteria.Paxes == nil {
			break
		}

		return e.complexity.RoomCriteria.Paxes(childComplexity), true

	case "RoomPrice.Breakdown":
		if e.complexity.RoomPrice.Breakdown == nil {
			break
		}

		return e.complexity.RoomPrice.Breakdown(childComplexity), true

	case "RoomPrice.Price":
		if e.complexity.RoomPrice.Price == nil {
			break
		}

		return e.complexity.RoomPrice.Price(childComplexity), true

	case "Rule.Id":
		if e.complexity.Rule.Id == nil {
			break
		}

		return e.complexity.Rule.Id(childComplexity), true

	case "Rule.Name":
		if e.complexity.Rule.Name == nil {
			break
		}

		return e.complexity.Rule.Name(childComplexity), true

	case "Rule.Type":
		if e.complexity.Rule.Type == nil {
			break
		}

		return e.complexity.Rule.Type(childComplexity), true

	case "Rule.Value":
		if e.complexity.Rule.Value == nil {
			break
		}

		return e.complexity.Rule.Value(childComplexity), true

	case "Search.Hotel":
		if e.complexity.Search.Hotel == nil {
			break
		}

		args, err := ec.field_Search_hotel_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Search.Hotel(childComplexity, args["token"].(*string), args["criteria"].(*HotelCriteriaSearchInput), args["settings"].(*domainHotelCommon.Settings), args["filter"].(*search.Filter)), true

	case "ServiceStatus.Code":
		if e.complexity.ServiceStatus.Code == nil {
			break
		}

		return e.complexity.ServiceStatus.Code(childComplexity), true

	case "ServiceStatus.Description":
		if e.complexity.ServiceStatus.Description == nil {
			break
		}

		return e.complexity.ServiceStatus.Description(childComplexity), true

	case "ServiceStatus.Type":
		if e.complexity.ServiceStatus.Type == nil {
			break
		}

		return e.complexity.ServiceStatus.Type(childComplexity), true

	case "Stat.Duration":
		if e.complexity.Stat.Duration == nil {
			break
		}

		return e.complexity.Stat.Duration(childComplexity), true

	case "Stat.End":
		if e.complexity.Stat.End == nil {
			break
		}

		return e.complexity.Stat.End(childComplexity), true

	case "Stat.Start":
		if e.complexity.Stat.Start == nil {
			break
		}

		return e.complexity.Stat.Start(childComplexity), true

	case "StatAccess.Cities":
		if e.complexity.StatAccess.Cities == nil {
			break
		}

		return e.complexity.StatAccess.Cities(childComplexity), true

	case "StatAccess.Hotels":
		if e.complexity.StatAccess.Hotels == nil {
			break
		}

		return e.complexity.StatAccess.Hotels(childComplexity), true

	case "StatAccess.Name":
		if e.complexity.StatAccess.Name == nil {
			break
		}

		return e.complexity.StatAccess.Name(childComplexity), true

	case "StatAccess.Plugins":
		if e.complexity.StatAccess.Plugins == nil {
			break
		}

		return e.complexity.StatAccess.Plugins(childComplexity), true

	case "StatAccess.RequestAccess":
		if e.complexity.StatAccess.RequestAccess == nil {
			break
		}

		return e.complexity.StatAccess.RequestAccess(childComplexity), true

	case "StatAccess.ResponseAccess":
		if e.complexity.StatAccess.ResponseAccess == nil {
			break
		}

		return e.complexity.StatAccess.ResponseAccess(childComplexity), true

	case "StatAccess.StaticConfiguration":
		if e.complexity.StatAccess.StaticConfiguration == nil {
			break
		}

		return e.complexity.StatAccess.StaticConfiguration(childComplexity), true

	case "StatAccess.Total":
		if e.complexity.StatAccess.Total == nil {
			break
		}

		return e.complexity.StatAccess.Total(childComplexity), true

	case "StatAccess.Transactions":
		if e.complexity.StatAccess.Transactions == nil {
			break
		}

		return e.complexity.StatAccess.Transactions(childComplexity), true

	case "StatAccess.Zones":
		if e.complexity.StatAccess.Zones == nil {
			break
		}

		return e.complexity.StatAccess.Zones(childComplexity), true

	case "StatPlugin.Name":
		if e.complexity.StatPlugin.Name == nil {
			break
		}

		return e.complexity.StatPlugin.Name(childComplexity), true

	case "StatPlugin.Total":
		if e.complexity.StatPlugin.Total == nil {
			break
		}

		return e.complexity.StatPlugin.Total(childComplexity), true

	case "StatTransaction.BuildRequest":
		if e.complexity.StatTransaction.BuildRequest == nil {
			break
		}

		return e.complexity.StatTransaction.BuildRequest(childComplexity), true

	case "StatTransaction.ParseResponse":
		if e.complexity.StatTransaction.ParseResponse == nil {
			break
		}

		return e.complexity.StatTransaction.ParseResponse(childComplexity), true

	case "StatTransaction.Reference":
		if e.complexity.StatTransaction.Reference == nil {
			break
		}

		return e.complexity.StatTransaction.Reference(childComplexity), true

	case "StatTransaction.Total":
		if e.complexity.StatTransaction.Total == nil {
			break
		}

		return e.complexity.StatTransaction.Total(childComplexity), true

	case "StatTransaction.WorkerCommunication":
		if e.complexity.StatTransaction.WorkerCommunication == nil {
			break
		}

		return e.complexity.StatTransaction.WorkerCommunication(childComplexity), true

	case "StatsRequest.Accesses":
		if e.complexity.StatsRequest.Accesses == nil {
			break
		}

		return e.complexity.StatsRequest.Accesses(childComplexity), true

	case "StatsRequest.Cities":
		if e.complexity.StatsRequest.Cities == nil {
			break
		}

		return e.complexity.StatsRequest.Cities(childComplexity), true

	case "StatsRequest.Configuration":
		if e.complexity.StatsRequest.Configuration == nil {
			break
		}

		return e.complexity.StatsRequest.Configuration(childComplexity), true

	case "StatsRequest.DockerID":
		if e.complexity.StatsRequest.DockerID == nil {
			break
		}

		return e.complexity.StatsRequest.DockerID(childComplexity), true

	case "StatsRequest.Hotels":
		if e.complexity.StatsRequest.Hotels == nil {
			break
		}

		return e.complexity.StatsRequest.Hotels(childComplexity), true

	case "StatsRequest.Process":
		if e.complexity.StatsRequest.Process == nil {
			break
		}

		return e.complexity.StatsRequest.Process(childComplexity), true

	case "StatsRequest.Request":
		if e.complexity.StatsRequest.Request == nil {
			break
		}

		return e.complexity.StatsRequest.Request(childComplexity), true

	case "StatsRequest.RequestPlugin":
		if e.complexity.StatsRequest.RequestPlugin == nil {
			break
		}

		return e.complexity.StatsRequest.RequestPlugin(childComplexity), true

	case "StatsRequest.Response":
		if e.complexity.StatsRequest.Response == nil {
			break
		}

		return e.complexity.StatsRequest.Response(childComplexity), true

	case "StatsRequest.ResponsePlugin":
		if e.complexity.StatsRequest.ResponsePlugin == nil {
			break
		}

		return e.complexity.StatsRequest.ResponsePlugin(childComplexity), true

	case "StatsRequest.Total":
		if e.complexity.StatsRequest.Total == nil {
			break
		}

		return e.complexity.StatsRequest.Total(childComplexity), true

	case "StatsRequest.Validation":
		if e.complexity.StatsRequest.Validation == nil {
			break
		}

		return e.complexity.StatsRequest.Validation(childComplexity), true

	case "StatsRequest.Zones":
		if e.complexity.StatsRequest.Zones == nil {
			break
		}

		return e.complexity.StatsRequest.Zones(childComplexity), true

	case "Supplement.ChargeType":
		if e.complexity.Supplement.ChargeType == nil {
			break
		}

		return e.complexity.Supplement.ChargeType(childComplexity), true

	case "Supplement.Code":
		if e.complexity.Supplement.Code == nil {
			break
		}

		return e.complexity.Supplement.Code(childComplexity), true

	case "Supplement.Description":
		if e.complexity.Supplement.Description == nil {
			break
		}

		return e.complexity.Supplement.Description(childComplexity), true

	case "Supplement.DurationType":
		if e.complexity.Supplement.DurationType == nil {
			break
		}

		return e.complexity.Supplement.DurationType(childComplexity), true

	case "Supplement.EffectiveDate":
		if e.complexity.Supplement.EffectiveDate == nil {
			break
		}

		return e.complexity.Supplement.EffectiveDate(childComplexity), true

	case "Supplement.ExpireDate":
		if e.complexity.Supplement.ExpireDate == nil {
			break
		}

		return e.complexity.Supplement.ExpireDate(childComplexity), true

	case "Supplement.Mandatory":
		if e.complexity.Supplement.Mandatory == nil {
			break
		}

		return e.complexity.Supplement.Mandatory(childComplexity), true

	case "Supplement.Name":
		if e.complexity.Supplement.Name == nil {
			break
		}

		return e.complexity.Supplement.Name(childComplexity), true

	case "Supplement.Price":
		if e.complexity.Supplement.Price == nil {
			break
		}

		return e.complexity.Supplement.Price(childComplexity), true

	case "Supplement.Quantity":
		if e.complexity.Supplement.Quantity == nil {
			break
		}

		return e.complexity.Supplement.Quantity(childComplexity), true

	case "Supplement.Resort":
		if e.complexity.Supplement.Resort == nil {
			break
		}

		return e.complexity.Supplement.Resort(childComplexity), true

	case "Supplement.SupplementType":
		if e.complexity.Supplement.SupplementType == nil {
			break
		}

		return e.complexity.Supplement.SupplementType(childComplexity), true

	case "Supplement.Unit":
		if e.complexity.Supplement.Unit == nil {
			break
		}

		return e.complexity.Supplement.Unit(childComplexity), true

	case "Surcharge.ChargeType":
		if e.complexity.Surcharge.ChargeType == nil {
			break
		}

		return e.complexity.Surcharge.ChargeType(childComplexity), true

	case "Surcharge.Description":
		if e.complexity.Surcharge.Description == nil {
			break
		}

		return e.complexity.Surcharge.Description(childComplexity), true

	case "Surcharge.Mandatory":
		if e.complexity.Surcharge.Mandatory == nil {
			break
		}

		return e.complexity.Surcharge.Mandatory(childComplexity), true

	case "Surcharge.Price":
		if e.complexity.Surcharge.Price == nil {
			break
		}

		return e.complexity.Surcharge.Price(childComplexity), true

	case "Transactions.Request":
		if e.complexity.Transactions.Request == nil {
			break
		}

		return e.complexity.Transactions.Request(childComplexity), true

	case "Transactions.Response":
		if e.complexity.Transactions.Response == nil {
			break
		}

		return e.complexity.Transactions.Response(childComplexity), true

	case "Transactions.TimeStamp":
		if e.complexity.Transactions.TimeStamp == nil {
			break
		}

		return e.complexity.Transactions.TimeStamp(childComplexity), true

	case "Warning.Code":
		if e.complexity.Warning.Code == nil {
			break
		}

		return e.complexity.Warning.Code(childComplexity), true

	case "Warning.Description":
		if e.complexity.Warning.Description == nil {
			break
		}

		return e.complexity.Warning.Description(childComplexity), true

	case "Warning.Type":
		if e.complexity.Warning.Type == nil {
			break
		}

		return e.complexity.Warning.Type(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:       buf,
		Errors:     ec.Errors,
		Extensions: ec.Extensions,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	return graphql.ErrorResponse(ctx, "mutations are not supported")
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

func (ec *executionContext) FieldMiddleware(ctx context.Context, obj interface{}, next graphql.Resolver) (ret interface{}) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "schema.graphql", Input: `schema {
  query: Query
}

type Query{
  hotelX: HotelXQuery
}

type HotelXQuery{
  # Available options of an hotel for a given date and itinerary. It does not filter different classes, times or
  # fares. It will always retrieve all results returned by the suppliers. The availability request is very straight
  # forward. It only requires the criteria of search (destination, travel dates and the number of pax in each room).
  # But you must preload the other fields in our system by complete the fields absents.
  search: HotelSearch

  # Returns status of the search service.
  searchStatusService: ServiceStatus!
}

# Available options for a given date and itinerary. It does not filter different classes, times or
# fares. It will always retrieve all results returned by the suppliers. The availability request is very straight
# forward.
type Search {
  # Available options of an hotel for a given date and itinerary. It does not filter different classes, times or
  # fares. It will always retrieve all results returned by the suppliers. The availability request is very straight
  # forward. It only requires the criteria of search (destination, travel dates and the number of pax in each room).
  # But you must preload the other fields in our system by complete the fields absents.
  hotel(token: String, criteria: HotelCriteriaSearchInput, settings: HotelSettingsInput, filter: FilterInput): HotelSearch @deprecated(reason: "deprecated from 2017-11-21. You can find it in query at HotelX")
}

# Business rules type
enum BusinessRulesType {
  # The cheapest options is returned without exceeding the optionsQuota limit.
  CHEAPER_AMOUNT
  
  # Groups the option by room type without exceeding the optionsQuota limit.
  ROOM_TYPE
}

# Options type
enum CancelPenaltyType {
  # Indicates the number of nights to be penalized.
  NIGHTS
  
  # Indicates the percentage to pay based on the option price.
  PERCENT
  
  # Indicates the exact amount payable.
  IMPORT
}

# Charge Type
enum ChargeType {
  # The charge is included.
  INCLUDE
  
  # The charge is excluded.
  EXCLUDE
}

# Duration Type
enum DurationType {
  # Date range is set.
  RANGE
  
  # Not restricted by date.
  OPEN
}

# Indicates what type of value is the markup, by percentage or is an import.
enum MarkupRuleType {
  # Indicates the percentage applied by a rule.
  PERCENT
  
  # Indicates the exact amount applied by a rule.
  IMPORT
}

# Plugin Step Type. https://docs.travelgatex.com/hotelx/plugins/overview/
enum PluginStepType {
  # Plugins executed after Buyer requests message to HotelX
  REQUEST
  
  # Plugins executed before sending request to Supplier using Access and after Accesses have been calculated
  REQUEST_ACCESS
  
  # Plugins executed after Supplier responds message. For every option returned
  RESPONSE_OPTION
  
  # Plugins executed after all Access options has been responded
  RESPONSE_ACCESS
  
  # Plugins executed before HotelX responds message to to Buyer
  RESPONSE
}

# Plugin Type. https://docs.travelgatex.com/hotelx/plugins/overview/
enum PluginType {
  # PRE_STEP is the first plugin that a step will execute, allows a full range of operations:
  # split arrays, join arrays, modify object values, add or remove object instances
  PRE_STEP
  
  # HOTEL_MAP allows to match Seller and Buyer hotel codes based on contexts
  HOTEL_MAP
  
  # BOARD_MAP allows to match Seller and Buyer board codes based on contexts
  BOARD_MAP
  
  # ROOM_MAP allows to match Seller and Buyer room codes based on contexts
  ROOM_MAP
  
  # CURRENCY_CONVERSION allows to match Seller and Buyer hotel codes based on contexts
  CURRENCY_CONVERSION
  
  # MARKUP allows to apply markup over price
  MARKUP
  
  # AGGREGATION allows to aggregate multiple supplier options
  AGGREGATION
  
  # POST_STEP is the last plugin that a step will execute, allows a full range of operations:
  # split arrays, join arrays, modify object values, add or remove object instances
  POST_STEP
}

# Price Type
enum PriceType {
  # Price without deductions.
  GROSS
  
  # Price after deducting all discounts and rebates.
  NET
  
  # Final quantity. Sum of multiple quantities.
  AMOUNT
}

# Service Type
enum ServiceType {
  # A ticket or pass authorizing the holder to ski in a certain place or resort. Gross.
  SKI_PASS
}

# Indicartes options status
enum StatusType {
  # The status of the avail is available
  OK
  
  # The status of the avail is On request
  RQ
}

# Supplement Type
enum SupplementType {
  # A ticket or pass authorizing the holder to ski in a certain place or resort.
  SKI_PASS
  
  # Lessons of any type that the costumer can take.
  LESSONS
  
  # Supplement of a determined meal plan.
  MEALS
  
  # Extra equipment for a specific purpose.
  EQUIPMENT
  
  # Admission to some service.
  TICKET
  
  # Transfers used by the costumer.
  TRANSFERS
  
  # Gala: A festive occasion, celebration or special entertainment.
  GALA
  
  # Activities that the costumer can do.
  ACTIVITY
}

# Unit Time Type
enum UnitTimeType {
  # Day
  DAY
  
  # Hour
  HOUR
}

# Options payment type
enum PaymentType {
  # The payment is managed by the supplier.
  MERCHANT
  
  # The payment is made straight to the actual payee, without sending it through an intermediary or a third party.
  DIRECT
  
  # The payment is managed by the supplier. The payment is effectuated at the time of booking.
  CARD_BOOKING
  
  # The payment is managed by the supplier. The payment is effectuated at check in in the hotel.
  CARD_CHECK_IN
}

# Rate Rules
enum RateRulesType {
  # The product can't be sold separately from another product attached to it, such as a flight.
  PACKAGE
  
  # Options that can only be sold to people who are 55 and older.
  OLDER55
  
  # Options that can only be sold to people who are 60 and older.
  OLDER60
  
  # Options that can only be sold to people who are 65 and older.
  OLDER65
  
  # The rate CanaryResident is applicable to Canary Islands residents only.
  CANARY_RESIDENT
  
  # The rate BalearicResident is applicable to Balearic Islands residents only.
  BALEARIC_RESIDENT
  
  # The rate largeFamily is applied to large families and is determined by each supplier
  LARGE_FAMILY
  
  # The rate honeymoon is applied to those who just got married and is determined by each supplier.
  HONEYMOON
  
  # The rate publicServant is applicable to public servants only.
  PUBLIC_SERVANT
  
  # The rate unemployed is applied to those without work.
  UNEMPLOYED

  #The rate normal refers to options without RateRule
  NORMAL

  #The rate non refundable is applied to non refundable options
  NON_REFUNDABLE
}

# Include *OR* exclude accesses in this specific search query. If not specified, default accesses will be used.
# Only one list (includes or excludes) *MUST* be used.
input AccessFilterInput {
  # These Access IDs will overwrite the default configuration. Only the IDs on this list will be used in the search query.
  includes: [ID!]
  
  # These Access IDs will overwrite the default configuration. The IDs on this list will be excluded from the search query.
  excludes: [ID!]
}

# List of business rules to use as filter on the options.
input BusinessRulesInput {
  # Options quota per search. Maximum numbers of options to be returned by the search query.
  optionsQuota: Int
  
  # Different business rules to filter the returned options.
  businessRulesType: BusinessRulesType
}

# The information and credentials required to access the supplier’s system.
input ConfigurationInput {
  # User name for the connection.
  username: String
  
  # Password for the connection
  password: String
  
  # URL or endpoint for the connection.
  urls:           UrlsInput!
  
  # List of parameters with additional required information.
  parameters: [ParameterInput!]
  
  # Source Markets allowed for the Access
  markets: [String!]
  
  # RateRules allowed for the access.
  rateRules: [RateRulesType!]
}

input HotelXFilterSearchInput{
  # Filter that selects the filter criteria which will be used in this availability. Currently you can only choose the accesses.
  # You must choose one of them, include or exclude, or the other alternative isn't specified anything.
  # If input both, you will receive a validation error that indicates this error.

  # You can specify one of the filters or any of them. In this latter case, all the configurated accesses will be executed.
  access: AccessFilterInput

  # If requested, only options with the specified rateRules will be returned
  rateRules: RateRulesFilterInput

  # Only is possible to specify one of this filters, it allows to filter which plugins have to be executed or excluded
  plugin: HotelXPluginFilterInput
}
# Filter that selects the filter criteria which will be used in this availability. Currently you can only choose the accesses.
# You must choose one of them, include or exclude, or the other alternative isn't specified anything.
# If input both, you will receive a validation error that indicates this error.
#@deprecated(reason: "deprecated from 2018-08-20. Please, use filterSearch")
input FilterInput {
  # You can specify one of the filters or any of them. In this latter case, all the configurated accesses will be executed.
  access: AccessFilterInput

  # If requested, only options with the specified rateRules will be returned
  rateRules: RateRulesFilterInput
}

# Search criteria contains destination, travel dates and the number of pax in each room.
# You must preload the other fields in our system by complete the fields absents.
input HotelCriteriaSearchInput {
  # Check-in date for booking
  # Format: YYYY-MM-DD
  checkIn: Date!
  
  # Check-out, booking date
  # Format: YYYY-MM-DD
  checkOut: Date!
  
  # Hotel Codes.
  hotels: [String!]

  # Destination codes.
  destinations: [String!]
  
  # For multi-room bookings, this array will contain multiple elements (rooms).
  # For each room you have to specify its own occupancy.
  occupancies: [RoomInput!]!
  
  # Language to be used in request
  language : Language
  
  # Currency requested if supported by supplier
  currency : Currency
  
  # Nationality of the guest (use ISO3166_1_alfa_2)
  nationality : Country
  
  # Targeted zone, country or point-ofsale-to be used in request.
  market : String
}

# Settings that you can edit for this avail. Values are loaded by default in our Back Office.
input HotelSettingsInput {
  # Indicates the context of the I/O codes (hotel, board, room and rates)
  context: String
  
  #Indicates if you want use context, or not, by default is true.
  #@deprecated(reason: "deprecated from 2017-12-12. Redundant.")
  useContext: Boolean
  
  # This field is occurs only if the authorization header is of the type JWT.. It is used to change the user that has been set by default in the preload.
  #@deprecated(reason: "deprecated from 2018-03-19. Redundant.")
  connectUser: String
  
  # Client name, this field is occurs only if the authorization header is of the type JWT.. It is used to change the user that has been set by default in the preload.
  client: ID
  
  # Group whose resources want to be used
  group: ID
  
  # Milliseconds before the connection is closed.
  timeout: Int
  
  # Returns all the transactions exchanged with the supplier.
  auditTransactions: Boolean
  
  # Business rules
  businessRules: BusinessRulesInput
  
  # Array of suppliers. Each one contains its own code, settings and accesses.
  suppliers: [HotelXSupplierInput!]
  
  # Array of plugins to execute.
  plugins: [PluginStepInput!]

  # This flag allows only the accesses checked as test. By default is production.
  testMode: Boolean

  # Used to identify the origin of the request, this is only used in plugins. 
  clientTokens: [String!] 
}

# AccessInput overwrites an existent access in our Back Office or creates a new
# one to be used in this search query only. An access object contains its own code, configuration and settings.
input HotelXAccessInput {
  # The accessID used to identify the existing access in our Back Office in order to
  # overwrite it. Acts as an identifier in this search. It can either exist or not.
  accessId: ID!
  
  # Information required to access the supplier's system.
  configuration: ConfigurationInput
  
  # You can configure an special settings for any access. This level overwrites the search and supplier settings levels.
  settings: SettingsBaseInput
}

# Supplier object. Contains its own settings, code and access.
input HotelXSupplierInput {
  # You can configure an special settings for any supplier. This level overwrites the avail settings level but not the
  # access settings level.
  settings: SettingsBaseInput
  
  # Code that represents a supplier in our system.
  # This information is mandatory.
  code: String!
  
  # Array of accesses that can overwrite an existing access information or include a new access for this avail.
  accesses: [HotelXAccessInput!]
}

# Pax object that contains the pax age.
input PaxInput {
  # Pax age.
  age: Int!
}

# If requested, only options with the specified rateRules will be returned
input RateRulesFilterInput {
  # if includes not nil: only options without rate rules and options with rate rules found in includes will be returned
  includes: [RateRulesType!]
  
  # if excludes not nil: only options without rate rules and options with rate rules that haven't been sent in excludes will be returned
  excludes: [RateRulesType!]
}

# Occupancy for a room. It contains a list of pax ages.
input RoomInput {
  # Array of pax ages. The number of items in the array will indicate the pax occupancy.
  paxes: [PaxInput!]!
}

# Plugin to execute.
input PluginsInput {
  # type of the plugins to execute
  type: PluginType!
  
  # name of plugin to execute
  name: String!
  
  # Plugin's parameters
  parameters: [ParameterInput!]
}

# Plugin to execute.
input PluginStepInput {
  # Indicates where the plugin will be executed.
  step: PluginStepType!
  
  # Indicates the plugin that will be executed.
  pluginsType: [PluginsInput!]
}

# Contains the time out and business rules of a supplier or an access.
input SettingsBaseInput {
  # Milliseconds before the connection is closed.
  timeout: Int
  
  # Specifies if transactions exchanged with the supplier have to be logged or not.
  auditTransactions: Boolean
  
  # Business rules
  businessRules: BusinessRulesInput

  # The currency
  currency: Currency
}

input HotelXPluginFilterInput{
  # Plugins to include (only these plugins will be executed)
  includes: [HotelXFilterPluginTypeInput!]
  # Plugins to exclude
  excludes: [HotelXFilterPluginTypeInput!]
}
input HotelXFilterPluginTypeInput{
  # The Step of the plugin to filter
  step: PluginStepType!
  # The Type of the plugin to filter
  type: String!
  # The Name of the plugin to filter
  name: String!
}
# Parameters Input.
input ParameterInput {  
  # Contains the keyword/Id to identify a parameter.
  # This information is mandatory.
  key: String!
  # Contains the parameter values.
  # This information is mandatory.
  value: String!
}

# URLs Input
input UrlsInput {
  # Specific URL for Availability method.
  search:         URI
  # Specific URL for Reservation method.
  quote:          URI
  # Specific URL for Valuation method.
  book:           URI
  # Supplier URL used for multiple methods.
  generic:        URI
}

interface BookableOptionSearch {
  # Supplier that offers this option.
  supplierCode: String!
  
  # Access code of this option.
  accessCode: String!
  
  # Indicates the id to be used on Quote as key
  id: String!
}

interface Priceable {
  # Specifies the currency.
  currency: Currency!
  
  # Is binding.
  binding: Boolean!
  
  # Specifies the import net.
  net: Float!
  
  # Specifies the import gross.
  gross: Float
  
  # Specifies the exchange.
  exchange: Exchange!
}

interface Response {
  # Application stats
  stats(token: String!): StatsRequest
  
  # Data sent and received in the supplier’s original format.
  auditData: AuditData
  
  # Errors that lead the service to stop
  errors: [Error!]
  
  # Potentially harmful situations or errors that do not stop the service
  warnings: [Warning!]
}

# Additional information about the option
type AddOns {
  # Extra information from the distribution layer
  distribute: JSON @deprecated(reason: "deprecated from 2018-05-21. You can find it in distribution AddOn")
  
  # Extra information from the distribution layer
  distribution: [AddOn!]
}

# Additional information about the option
type AddOn {
  # Contains keyword/ID to identify the AddOn.
  key: String!
  
  # Contains AddOn values.
  value: JSON!
}

# Data sent and received in the supplier’s native format.
type AuditData {
  # List of transactions data
  transactions:    [Transactions!]!
  
  # TimeStamp
  timeStamp:       DateTime!
  
  # Process time in milliseconds (ms)
  processTime:     Float!
}

# Contains information about a bed.
type Bed {
  # Specifies the bed type
  type: String
  
  # Description about the bed
  description: String
  
  # Indicates number of beds in a room
  count: Int
  
  # Specifies if the bed is shared or not
  shared: Boolean
}

# Contains information for cancellation penalities..
type CancelPenalty {
  # Cancellation fees applicable X number of hours before the check-in date
  hoursBefore: Int!
  
  # Type of penalty; this can be Nights, Percent or Import
  penaltyType: CancelPenaltyType!
  
  # Currency used in the cancellation policy
  currency: Currency!
  
  # Value of the cancellation policy
  value: Float!
}

# Information about a policy cancellation.
type CancelPolicy {
  # Indicates if the option is refundable or non-refundable
  refundable: Boolean!
  
  # List of cancellation penalties
  cancelPenalties: [CancelPenalty!]
}

# Search criteria contains destination, travel dates and the number of pax in each room.
type CriteriaSearch {
  # Check-in date for booking
  # Format: YYYY-MM-DD
  checkIn: Date!
  
  # Check-out, booking date
  # Format: YYYY-MM-DD
  checkOut: Date!
  
  # Contains the list of hotels's ID
  hotels: [String!]!
  
  # For multi-room bookings, this array will contain multiple elements (rooms).
  # For each room you have to specify its own occupancy.
  occupancies: [RoomCriteria!]!
  
  # Language to be used in request
  language : Language
  
  # Currency requested if supported by supplier
  currency : Currency
  
  # Nationality of the guest (use ISO3166_1_alfa_2)
  nationality : Country
  
  # Targeted zone, country or point-ofsale-to be used in request.
  market : String!
}

# Provides information about the currency of original, and its rate applied over the results returned by the Supplier.
type Exchange {
  # Provide information about the currency of origin
  currency: Currency!
  
  # Provides information about the rate applied over results
  rate: Float!
}

# An option includes hotel information, meal plan, total price, conditions and room description
type HotelOptionSearch implements BookableOptionSearch {
  # Supplier that offers this option.
  supplierCode: String!
  
  # Access code of this option.
  accessCode: String!
  
  # Market of this option.
  market: String!
  
  # Code of the hotel in the context selected.
  hotelCode: String!
  
  # Supplier's hotel code.
  hotelCodeSupplier: String!
  
  # Name of the hotel.
  hotelName: String
  
  # Code of the board in the context selected.
  boardCode: String!
  
  # Supplier's board code.
  boardCodeSupplier: String!
  
  # Indicates the payment type of the option returned. Possible options: Merchant, Direct, Card Booking, Card check in and Mixed.
  paymentType: PaymentType!
  
  # The possible values in status in response are Available (OK) or On Request (RQ).
  status: StatusType!
  
  # List of occupancies for the request
  occupancies: [Occupancy!]!
  
  # List of rooms of the option returned.
  rooms: [Room!]!
  
  # Specifies the prices (Gross, Net and Amount) of the option returned.
  price: Price!
  
  # List of supplements of the option returned.
  supplements: [Supplement]
  
  # List of surcharges of the option returned.
  surcharges: [Surcharge!]!
  
  # Specifies rate rules of the option returned.
  rateRules: [RateRulesType!]
  
  # Specifies cancel policies of the option returned.
  cancelPolicy: CancelPolicy
  
  # Additional information about the option.
  remarks: String
  
  # Additional information about the option
  addOns: AddOns
  
  # Token for Deep Link
  token: String!
  
  # Indicates the quote key
  id: String!
}

# Results from Avail Hotel; contains all the available options for a given date and itinerary
type HotelSearch implements Response {
  # Indicates the context of the response.
  context: String
  
  # Application stats in string format
  stats(token: String!): StatsRequest
  
  # Data sent and received in the supplier's native format.
  auditData: AuditData
  
  # Request Criteria
  requestCriteria: CriteriaSearch
  
  # List of options returned according to the request.
  options: [HotelOptionSearch]
  
  # Errors that abort services
  errors: [Error!]
  
  # Potentially harmful situations or errors that won't force the service to abort
  warnings: [Warning!]
}

# Informs markup applied over supplier price.
type Markup implements Priceable {
  #channel of markup application.
  channel: String
  
  # Currency code indicating which currency should be paid.
  # This information is mandatory.
  currency: Currency!
  
  # It indicates if the price indicated in the gross must be respected.
  # That is, the customer can not sell the room / option at a price lower than that established by the supplier.
  # This information is mandatory.
  binding: Boolean!
  
  # Indicates the net price that the customer must pay to the supplier plus the markup.
  # This information is mandatory.
  net: Float!
  
  # Indicates the retail price that the supplier sells to the customer plus the markup.
  gross: Float
  
  # Informs about the currency of origin, and the rate applied over result.
  # This information is mandatory.
  exchange: Exchange!
  
  # Breakdown of the applied rules for a markup
  rules: [Rule!]!
}

# Information about occupancy.
type Occupancy {
  # Unique ID room in this option.
  id: Int!
  
  # List of pax of this occupancy.
  paxes: [Pax!]!
}

# Specifies the age pax. The range of what is considered an adult, infant or baby is particular to each supplier.
type Pax {
  # Specifies the age pax.
  age: Int!
}

# Price indicates the value of the room/option.
# Supplements and/or surcharges can be included into the price, and will be verified with nodes Supplements/Surcharges.
type Price implements Priceable {
  # Currency code indicating which currency should be paid.
  # This information is mandatory.
  currency: Currency!
  
  # It indicates if the price indicated in the gross must be respected.
  # That is, the customer can not sell the room / option at a price lower than that established by the supplier.
  # This information is mandatory.
  binding: Boolean!
  
  # Indicates the net price that the customer must pay to the supplier.
  # This information is mandatory.
  net: Float!
  
  # Indicates the retail price that the supplier sells to the customer.
  gross: Float
  
  # Provides information about the currency of original, and its rate applied over the results returned by the Supplier.
  # This information is mandatory.
  exchange: Exchange!
  
  # Informs markup applied over supplier price.
  markups: [Markup!]
}

# Contains internal information.
type StatsRequest {
  # Total transaction time
  total:          Stat!
  
  # Request validation time
  validation:     Stat!
  
  # Process time. Contains communication time, parse time and plugin time.
  process:        Stat!
  
  # Build access time
  configuration:	Stat!
  
  # Request time
  request:				Stat!
  
  # Response time
  response:       Stat!
  
  # Plugin execution time
  requestPlugin:  StatPlugin
  
  # Plugin execution time
  responsePlugin: StatPlugin
  
  # Number of hotels
  hotels:         Int!
  
  # Number of zones
  zones:          Int!
  
  # Number of cities
  cities:         Int!
  
  # Docker Id
  dockerID:       String!
  
  # Detail access time
  Accesses:       [StatAccess!]!
}

# Information about daily price.
type PriceBreakdown {
  # Start date in which the price becomes effective.
  effectiveDate: Date!
  
  # Expire date of price.
  expireDate: Date!
  
  # Specifies the daily price.
  price: Price!
}

# Information about room promotions(offers).
type Promotion {
  # Specifies the promotion code.
  code: String!
  
  # Specifies the promotion name.
  name: String
  
  # Promotion effective date.
  effectiveDate: Date
  
  # Promotion expire date.
  expireDate: Date
}

# Information about the rate of the option returned.
type RatePlan {
  # Specifies the rate code.
  code: String!
  
  # Specifies the rate name.
  name: String
  
  # Start date in which the rate becomes effective.
  effectiveDate: Date
  
  # Expire date of the rate.
  expireDate: Date
}

# Contains information about the Resort.
type Resort {
  # Specifies the resort code.
  code: String!
  
  # Specifies the resort name.
  name: String
  
  # Specifies the resort description.
  description: String
}

# Contains the room information of the option returned.
type Room {
  # ID reference to the occupancy
  occupancyRefId: Int!
  
  # Indicates the room code
  code: String!
  
  # Description about the room
  description: String
  
  # Identifies if the room is refundable or not.
  refundable: Boolean
  
  # Number of rooms available with the same type.
  units: Int
  
  # Specifies the room price.
  roomPrice: RoomPrice!
  
  # List of beds.
  beds: [Bed!]
  
  # Daily break downs rate plan.
  ratePlans: [RatePlan!]
  
  # Daily break downs promotions.
  promotions: [Promotion!]
}

# Occupancy for a room. It contains a list of pax ages.
type RoomCriteria {
  # Array of pax ages. The number of items in the array will indicate the pax occupancy.
  paxes: [Pax!]!
}

# Specifies the room price.
type RoomPrice {
  # Total price for all days.
  price: Price!
  
  # Daily break downs price.
  breakdown: [PriceBreakdown!]
}

type Rule {
  # rule identifier
  id: String!
  
  # rule name
  name: String
  
  # type of the value
  type: MarkupRuleType!
  
  # value applied by this rule
  value: Float!
}

# Indicates the status of the service
type ServiceStatus{
  # Status code
  code: String
  
  # Status type
  type: String
  
  # Status description
  description : String
}

type Stat {
  # Start UTC
  start:      DateTime!
  
  # End UTC
  end:        DateTime!
  
  # Difference between start and end in miliseconds
  duration:   Float
}

type StatAccess {
  # Access name
  name:                   String!
  
  # Total access time
  total:                  Stat!
  
  # Static configuration time
  staticConfiguration:    Stat
  
  # Number of hotels
  hotels:                 Int!
  
  # Number of zones
  zones:                  Int!
  
  # Number of cities
  cities:                 Int!
  
  # Access request time
  requestAccess:          StatPlugin
  
  # Access response time
  responseAccess:         StatPlugin
  
  # Detail transaction time
  transactions:           [StatTransaction!]!
  
  # Plugin execution time
  plugins:                [StatPlugin!]
}

type StatTransaction {
  # Extra information about transaction.
  reference:              String!
  
  # Total transaction time
  total:                  Stat!
  
  # Build request time
  buildRequest:           Stat!
  
  # Worker connection time
  workerCommunication:    Stat!
  
  # Parse response time
  parseResponse:          Stat!
}

type StatPlugin{
  # Plugin name
  name:     String!
  
  # total plugin time
  total:    Stat!
}

# Supplement that it can be or its already added to the option returned. Contains all the information about the supplement.
type Supplement {
  # Specifies the supplement code.
  code: String!
  
  # Specifies the supplement name.
  name: String
  
  # Specifies the supplement description.
  description: String
  
  # Indicates the supplement type. Possible types: Fee, Ski_pass, Lessons, Meals, Equipment, Ticket, Transfers, Gla, Activity or Null.
  supplementType: SupplementType!
  
  # Indicates the charge types. We need to know whether the supplements have to be paid when the consumer gets to the hotel or beforehand.
  # Possible charge types: Include or Exclude.
  # when include: this supplement is mandatory and included in the option's price
  # when exclude: this supplement is not included in the option's price
  chargeType: ChargeType!
  
  # Indicates if the supplement is mandatory or not. If mandatory, this supplement will be applied to this option
  # if the chargeType is excluded the customer will have to pay it directly at the hotel
  mandatory: Boolean!
  
  # Specifies the duration type. Possible duration types: Range (specified dates) or Open. This field is mandatory for PDI.
  durationType: DurationType
  
  # Indicates the quantity of field in the element "unit".
  quantity: Int
  
  # Indicates the unit type. Possible unit types: Day or Hour.
  unit: UnitTimeType
  
  # Indicates the effective date of the supplement.
  effectiveDate: Date
  
  # Indicates the expire date of the supplement.
  expireDate: Date
  
  # Contains information about the resort
  resort: Resort
  
  # Indicates the supplement price.
  price: Price
}

# Surcharge that it can be or it is already added to the option returned. Contains all the information about the surcharge.
type Surcharge {
  # Indicates the charge types. We need to know whether the supplements have to be paid when the consumer gets to the hotel or beforehand.
  # Possible charge types: Include or Exclude.
  # when include: this surcharge is mandatory and included in the option's price
  # when exclude: this surcharge is not included in the option's price
  chargeType: ChargeType!
  
  # Indicates if the surcharge is mandatory or not. If mandatory, this surcharge will be applied to this option
  # if the chargeType is excluded the customer will have to pay it directly at the hotel
  mandatory: Boolean!
  
  # Indicates the surcharge price.
  price: Price!
  
  # Specifies the surcharge description.
  description: String
}

# Supplier transaction
type Transactions {
  # Transaction Request.
  request:        String!
  
  # Transaction Response.
  response:       String!
  
  # Time when the request has been processed.
  timeStamp:      DateTime!
}

# Application errors
type Error {
  # Error code
  code: String!

  # Error type
  type: String!

  # Error description
  description : String!
}

# Application warnings
type Warning {
  # Warning code
  code: String!

  # Warning type
  type: String!

  # Warning description
  description : String!
}

# The Country type represents Country values. A good example might be a Passenger Nationality.
# In queries or mutations, Country fields have to be specified in ISO 3166-1 alpha-2 format with enclosing double quotes "ES".
scalar Country

# The Currenty type represents Currency values. A good example might be a Rate Price Currency.
# In queries or mutations, Currency fields have to be specified in ISO 4217 format with enclosing double quotes "EUR".
scalar Currency

# The Date type represents Date values. A good example might be a Hotel CheckIn Date.
# In queries or mutations, DateTime fields have to be specified in ISO 8601 format with enclosing double quotes: "2017-10-22".
scalar Date

# The DateTime type represents DateTime values. A good example might be a transaction TimeSpan.
# In queries or mutations, DateTime fields have to be specified in ISO 8601 format with enclosing double quotes: "2017-10-22T13:57:31.123Z".
scalar DateTime

# The JSON type makes sure that it is actually valid JSON and returns the value as a parsed JSON object/array instead of a string.
# In queries or mutations, JSON fields have to be specified with enclosing double quotes. Special characters have to be escaped: "{\"int\": 1, \"string\": \"value\"}".
scalar JSON

# The Language type represents Language values. A good example might be a Hotel Description Language.
# In queries or mutations, Language fields have to be specified in ISO 3166-1 alpha-2 format with enclosing double quotes "es".
scalar Language

# The URI type represents a URI values. A good example mith be an Hotel Image URL.
# In queries or mutations, URI fields have to be specified in RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string format with enclosing double quotes: "http:\\www.travelgatex.com".
scalar URI

`},
)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_HotelSearch_stats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["token"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["token"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Search_hotel_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["token"]; ok {
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["token"] = arg0
	var arg1 *HotelCriteriaSearchInput
	if tmp, ok := rawArgs["criteria"]; ok {
		arg1, err = ec.unmarshalOHotelCriteriaSearchInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐHotelCriteriaSearchInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["criteria"] = arg1
	var arg2 *domainHotelCommon.Settings
	if tmp, ok := rawArgs["settings"]; ok {
		arg2, err = ec.unmarshalOHotelSettingsInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSettings(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["settings"] = arg2
	var arg3 *search.Filter
	if tmp, ok := rawArgs["filter"]; ok {
		arg3, err = ec.unmarshalOFilterInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋsearchᚐFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filter"] = arg3
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AddOn_key(ctx context.Context, field graphql.CollectedField, obj *AddOn) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AddOn",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AddOn_value(ctx context.Context, field graphql.CollectedField, obj *AddOn) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AddOn",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNJSON2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AddOns_distribute(ctx context.Context, field graphql.CollectedField, obj *AddOns) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AddOns",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distribute, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOJSON2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _AddOns_distribution(ctx context.Context, field graphql.CollectedField, obj *AddOns) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AddOns",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distribution, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]AddOn)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOAddOn2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐAddOn(ctx, field.Selections, res)
}

func (ec *executionContext) _AuditData_transactions(ctx context.Context, field graphql.CollectedField, obj *common.AuditData) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AuditData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transactions, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]common.Transactions)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNTransactions2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋcommonᚐTransactions(ctx, field.Selections, res)
}

func (ec *executionContext) _AuditData_timeStamp(ctx context.Context, field graphql.CollectedField, obj *common.AuditData) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AuditData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeStamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _AuditData_processTime(ctx context.Context, field graphql.CollectedField, obj *common.AuditData) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "AuditData",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessTime, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Bed_type(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Bed) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Bed",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Bed_description(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Bed) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Bed",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Bed_count(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Bed) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Bed",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _Bed_shared(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Bed) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Bed",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Shared, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _CancelPenalty_hoursBefore(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.CancelPenalty) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CancelPenalty",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HoursBefore, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CancelPenalty_penaltyType(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.CancelPenalty) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CancelPenalty",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.CancelPenaltyType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCancelPenaltyType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐCancelPenaltyType(ctx, field.Selections, res)
}

func (ec *executionContext) _CancelPenalty_currency(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.CancelPenalty) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CancelPenalty",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCurrency2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CancelPenalty_value(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.CancelPenalty) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CancelPenalty",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CancelPolicy_refundable(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.CancelPolicy) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CancelPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Refundable, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CancelPolicy_cancelPenalties(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.CancelPolicy) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CancelPolicy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CancelPenalties, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.CancelPenalty)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOCancelPenalty2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐCancelPenalty(ctx, field.Selections, res)
}

func (ec *executionContext) _CriteriaSearch_checkIn(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CriteriaSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CheckIn, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CriteriaSearch_checkOut(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CriteriaSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CheckOut, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CriteriaSearch_hotels(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CriteriaSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hotels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _CriteriaSearch_occupancies(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CriteriaSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Occupancies, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]RoomCriteria)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNRoomCriteria2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐRoomCriteria(ctx, field.Selections, res)
}

func (ec *executionContext) _CriteriaSearch_language(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CriteriaSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Language, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOLanguage2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _CriteriaSearch_currency(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CriteriaSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOCurrency2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _CriteriaSearch_nationality(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CriteriaSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nationality, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOCountry2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _CriteriaSearch_market(ctx context.Context, field graphql.CollectedField, obj *CriteriaSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "CriteriaSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Market, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Error_code(ctx context.Context, field graphql.CollectedField, obj *common.AdviseMessage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Error",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Error_type(ctx context.Context, field graphql.CollectedField, obj *common.AdviseMessage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Error",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Error_description(ctx context.Context, field graphql.CollectedField, obj *common.AdviseMessage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Error",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Exchange_currency(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Exchange) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Exchange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCurrency2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Exchange_rate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Exchange) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Exchange",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rate, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_supplierCode(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Supplier, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_accessCode(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Access, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_market(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Market, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_hotelCode(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HotelCode, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_hotelCodeSupplier(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HotelCodeSupplier(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_hotelName(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HotelName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_boardCode(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BoardCode, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_boardCodeSupplier(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BoardCodeOriginal, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_paymentType(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PaymentType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.PaymentType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPaymentType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPaymentType(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_status(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.StatusType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStatusType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐStatusType(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_occupancies(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Occupancies, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Occupancy)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNOccupancy2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐOccupancy(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_rooms(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rooms, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Room)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNRoom2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐRoom(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_price(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.Price)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPrice2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPrice(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_supplements(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Supplements, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*domainHotelCommon.Supplement)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOSupplement2ᚕᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSupplement(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_surcharges(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Surcharges, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Surcharge)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNSurcharge2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSurcharge(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_rateRules(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.HotelOptionSearch().RateRules(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]RateRulesType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalORateRulesType2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐRateRulesType(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_cancelPolicy(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CancelPolicy, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*domainHotelCommon.CancelPolicy)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOCancelPolicy2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐCancelPolicy(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_remarks(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Remarks, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_addOns(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.HotelOptionSearch().AddOns(rctx, obj)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AddOns)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOAddOns2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐAddOns(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_token(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Token, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelOptionSearch_id(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Option) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelOptionSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OptionID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelSearch_context(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Context, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelSearch_stats(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_HotelSearch_stats_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stats, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*StatsRequest)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOStatsRequest2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatsRequest(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelSearch_auditData(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuditData, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*common.AuditData)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOAuditData2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋcommonᚐAuditData(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelSearch_requestCriteria(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestCriteria, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*CriteriaSearch)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOCriteriaSearch2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐCriteriaSearch(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelSearch_options(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Options, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*domainHotelCommon.Option)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOHotelOptionSearch2ᚕᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐOption(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelSearch_errors(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]common.AdviseMessage)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOError2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋcommonᚐAdviseMessage(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelSearch_warnings(ctx context.Context, field graphql.CollectedField, obj *HotelSearch) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelSearch",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Warnings, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]common.AdviseMessage)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOWarning2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋcommonᚐAdviseMessage(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelXQuery_search(ctx context.Context, field graphql.CollectedField, obj *HotelXQuery) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelXQuery",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Search, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*HotelSearch)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOHotelSearch2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐHotelSearch(ctx, field.Selections, res)
}

func (ec *executionContext) _HotelXQuery_searchStatusService(ctx context.Context, field graphql.CollectedField, obj *HotelXQuery) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "HotelXQuery",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SearchStatusService, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(ServiceStatus)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNServiceStatus2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐServiceStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _Markup_channel(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Markup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Channel, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Markup_currency(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Markup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCurrency2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Markup_binding(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Markup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Binding, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Markup_net(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Markup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Net, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Markup_gross(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Markup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gross, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Markup_exchange(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Markup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exchange, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.Exchange)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNExchange2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐExchange(ctx, field.Selections, res)
}

func (ec *executionContext) _Markup_rules(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Markup) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Markup",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rules, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Rule)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNRule2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐRule(ctx, field.Selections, res)
}

func (ec *executionContext) _Occupancy_id(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Occupancy) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Occupancy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Occupancy_paxes(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Occupancy) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Occupancy",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Paxes, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Pax)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPax2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPax(ctx, field.Selections, res)
}

func (ec *executionContext) _Pax_age(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Pax) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Pax",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Age, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Price_currency(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Price) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Price",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNCurrency2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Price_binding(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Price) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Price",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Binding, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Price_net(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Price) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Price",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Net, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Price_gross(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Price) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Price",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gross, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Price_exchange(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Price) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Price",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exchange, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.Exchange)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNExchange2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐExchange(ctx, field.Selections, res)
}

func (ec *executionContext) _Price_markups(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Price) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Price",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Markups, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Markup)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOMarkup2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐMarkup(ctx, field.Selections, res)
}

func (ec *executionContext) _PriceBreakdown_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.PriceBreakDown) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "PriceBreakdown",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PriceBreakdown_expireDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.PriceBreakDown) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "PriceBreakdown",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpireDate, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDate2string(ctx, field.Selections, res)
}

func (ec *executionContext) _PriceBreakdown_price(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.PriceBreakDown) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "PriceBreakdown",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.Price)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPrice2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPrice(ctx, field.Selections, res)
}

func (ec *executionContext) _Promotion_code(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Promotion) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Promotion",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Promotion_name(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Promotion) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Promotion",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Promotion_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Promotion) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Promotion",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODate2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Promotion_expireDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Promotion) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Promotion",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpireDate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODate2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_hotelX(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().HotelX(rctx)
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*HotelXQuery)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOHotelXQuery2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐHotelXQuery(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Query",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _RatePlan_code(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.RatePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "RatePlan",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _RatePlan_name(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.RatePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "RatePlan",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _RatePlan_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.RatePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "RatePlan",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODate2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _RatePlan_expireDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.RatePlan) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "RatePlan",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpireDate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODate2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Resort_code(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Resort) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Resort",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Resort_name(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Resort) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Resort",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Resort_description(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Resort) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Resort",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Room_occupancyRefId(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Room",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OccupancyRefID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _Room_code(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Room",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Room_description(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Room",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Room_refundable(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Room",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Refundable, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) _Room_units(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Room",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Units, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _Room_roomPrice(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Room",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoomPrice, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.RoomPrice)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNRoomPrice2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐRoomPrice(ctx, field.Selections, res)
}

func (ec *executionContext) _Room_beds(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Room",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Beds, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Bed)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOBed2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐBed(ctx, field.Selections, res)
}

func (ec *executionContext) _Room_ratePlans(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Room",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RatePlans, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.RatePlan)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalORatePlan2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐRatePlan(ctx, field.Selections, res)
}

func (ec *executionContext) _Room_promotions(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Room) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Room",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Promotions, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Promotion)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOPromotion2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPromotion(ctx, field.Selections, res)
}

func (ec *executionContext) _RoomCriteria_paxes(ctx context.Context, field graphql.CollectedField, obj *RoomCriteria) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "RoomCriteria",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Paxes, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.Pax)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPax2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPax(ctx, field.Selections, res)
}

func (ec *executionContext) _RoomPrice_price(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.RoomPrice) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "RoomPrice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.Price)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPrice2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPrice(ctx, field.Selections, res)
}

func (ec *executionContext) _RoomPrice_breakdown(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.RoomPrice) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "RoomPrice",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Breakdown, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]domainHotelCommon.PriceBreakDown)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOPriceBreakdown2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPriceBreakDown(ctx, field.Selections, res)
}

func (ec *executionContext) _Rule_id(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Rule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Rule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Rule_name(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Rule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Rule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Rule_type(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Rule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Rule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.MarkupRuleType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNMarkupRuleType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐMarkupRuleType(ctx, field.Selections, res)
}

func (ec *executionContext) _Rule_value(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Rule) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Rule",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _Search_hotel(ctx context.Context, field graphql.CollectedField, obj *Search) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Search",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Search_hotel_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hotel, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*HotelSearch)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOHotelSearch2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐHotelSearch(ctx, field.Selections, res)
}

func (ec *executionContext) _ServiceStatus_code(ctx context.Context, field graphql.CollectedField, obj *ServiceStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ServiceStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ServiceStatus_type(ctx context.Context, field graphql.CollectedField, obj *ServiceStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ServiceStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _ServiceStatus_description(ctx context.Context, field graphql.CollectedField, obj *ServiceStatus) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "ServiceStatus",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Stat_start(ctx context.Context, field graphql.CollectedField, obj *Stat) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Stat",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Start, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Stat_end(ctx context.Context, field graphql.CollectedField, obj *Stat) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Stat",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.End, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Stat_duration(ctx context.Context, field graphql.CollectedField, obj *Stat) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Stat",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) _StatAccess_name(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatAccess",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _StatAccess_total(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatAccess",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatAccess_staticConfiguration(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatAccess",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StaticConfiguration, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOStat2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatAccess_hotels(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatAccess",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hotels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _StatAccess_zones(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatAccess",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Zones, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _StatAccess_cities(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatAccess",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cities, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _StatAccess_requestAccess(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatAccess",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestAccess, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*StatPlugin)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOStatPlugin2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatPlugin(ctx, field.Selections, res)
}

func (ec *executionContext) _StatAccess_responseAccess(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatAccess",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseAccess, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*StatPlugin)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOStatPlugin2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatPlugin(ctx, field.Selections, res)
}

func (ec *executionContext) _StatAccess_transactions(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatAccess",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Transactions, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]StatTransaction)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStatTransaction2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatTransaction(ctx, field.Selections, res)
}

func (ec *executionContext) _StatAccess_plugins(ctx context.Context, field graphql.CollectedField, obj *StatAccess) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatAccess",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Plugins, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]StatPlugin)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOStatPlugin2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatPlugin(ctx, field.Selections, res)
}

func (ec *executionContext) _StatPlugin_name(ctx context.Context, field graphql.CollectedField, obj *StatPlugin) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatPlugin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _StatPlugin_total(ctx context.Context, field graphql.CollectedField, obj *StatPlugin) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatPlugin",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatTransaction_reference(ctx context.Context, field graphql.CollectedField, obj *StatTransaction) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reference, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _StatTransaction_total(ctx context.Context, field graphql.CollectedField, obj *StatTransaction) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatTransaction_buildRequest(ctx context.Context, field graphql.CollectedField, obj *StatTransaction) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildRequest, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatTransaction_workerCommunication(ctx context.Context, field graphql.CollectedField, obj *StatTransaction) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkerCommunication, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatTransaction_parseResponse(ctx context.Context, field graphql.CollectedField, obj *StatTransaction) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatTransaction",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParseResponse, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_total(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Total, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_validation(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Validation, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_process(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Process, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_configuration(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Configuration, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_request(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Request, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_response(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Response, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Stat)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStat2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStat(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_requestPlugin(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequestPlugin, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*StatPlugin)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOStatPlugin2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatPlugin(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_responsePlugin(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponsePlugin, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*StatPlugin)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOStatPlugin2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatPlugin(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_hotels(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hotels, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_zones(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Zones, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_cities(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cities, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_dockerID(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DockerID, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _StatsRequest_Accesses(ctx context.Context, field graphql.CollectedField, obj *StatsRequest) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "StatsRequest",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Accesses, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]StatAccess)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNStatAccess2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatAccess(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_code(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_name(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_description(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_supplementType(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SupplementType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.SupplementType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNSupplementType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSupplementType(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_chargeType(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChargeType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.ChargeType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNChargeType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐChargeType(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_mandatory(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mandatory, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_durationType(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DurationType, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*domainHotelCommon.DurationType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODurationType2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐDurationType(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_quantity(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Quantity, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_unit(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unit, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*domainHotelCommon.UnitTimeType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOUnitTimeType2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐUnitTimeType(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_effectiveDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EffectiveDate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODate2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_expireDate(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpireDate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalODate2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_resort(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resort, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*domainHotelCommon.Resort)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOResort2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐResort(ctx, field.Selections, res)
}

func (ec *executionContext) _Supplement_price(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Supplement",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*domainHotelCommon.Price)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOPrice2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPrice(ctx, field.Selections, res)
}

func (ec *executionContext) _Surcharge_chargeType(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Surcharge) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Surcharge",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChargeType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.ChargeType)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNChargeType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐChargeType(ctx, field.Selections, res)
}

func (ec *executionContext) _Surcharge_mandatory(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Surcharge) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Surcharge",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mandatory, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _Surcharge_price(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Surcharge) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Surcharge",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(domainHotelCommon.Price)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNPrice2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPrice(ctx, field.Selections, res)
}

func (ec *executionContext) _Surcharge_description(ctx context.Context, field graphql.CollectedField, obj *domainHotelCommon.Surcharge) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Surcharge",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) _Transactions_request(ctx context.Context, field graphql.CollectedField, obj *common.Transactions) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Transactions",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Request, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transactions_response(ctx context.Context, field graphql.CollectedField, obj *common.Transactions) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Transactions",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Response, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Transactions_timeStamp(ctx context.Context, field graphql.CollectedField, obj *common.Transactions) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Transactions",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeStamp, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNDateTime2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Warning_code(ctx context.Context, field graphql.CollectedField, obj *common.AdviseMessage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Warning",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Warning_type(ctx context.Context, field graphql.CollectedField, obj *common.AdviseMessage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Warning",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Warning_description(ctx context.Context, field graphql.CollectedField, obj *common.AdviseMessage) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "Warning",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__DirectiveLocation2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Directive",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__EnumValue",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Field",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__InputValue",
		Field:    field,
		Args:     nil,
		IsMethod: false,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Schema",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx.Args = args
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rctx := &graphql.ResolverContext{
		Object:   "__Type",
		Field:    field,
		Args:     nil,
		IsMethod: true,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAccessFilterInput(ctx context.Context, v interface{}) (search.TypeFilter, error) {
	var it search.TypeFilter
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "includes":
			var err error
			it.Includes, err = ec.unmarshalOID2ᚖᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "excludes":
			var err error
			it.Excludes, err = ec.unmarshalOID2ᚖᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBusinessRulesInput(ctx context.Context, v interface{}) (domainHotelCommon.BusinessRules, error) {
	var it domainHotelCommon.BusinessRules
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "optionsQuota":
			var err error
			it.OptionsQuota, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "businessRulesType":
			var err error
			it.BusinessRulesType, err = ec.unmarshalOBusinessRulesType2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐBusinessRulesType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputConfigurationInput(ctx context.Context, v interface{}) (access.AccessConfiguration, error) {
	var it access.AccessConfiguration
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "username":
			var err error
			it.Username, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "password":
			var err error
			it.Password, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "urls":
			var err error
			it.Urls, err = ec.unmarshalNUrlsInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋaccessᚐUrls(ctx, v)
			if err != nil {
				return it, err
			}
		case "parameters":
			var err error
			it.Parameters, err = ec.unmarshalOParameterInput2ᚖᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋaccessᚐParameter(ctx, v)
			if err != nil {
				return it, err
			}
		case "markets":
			var err error
			it.Markets, err = ec.unmarshalOString2ᚖᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "rateRules":
			var err error
			it.RateRules, err = ec.unmarshalORateRulesType2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐRateRulesType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFilterInput(ctx context.Context, v interface{}) (search.Filter, error) {
	var it search.Filter
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "access":
			var err error
			it.Access, err = ec.unmarshalOAccessFilterInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋsearchᚐTypeFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "rateRules":
			var err error
			it.RateRules, err = ec.unmarshalORateRulesFilterInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋsearchᚐRateRuleFilter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHotelCriteriaSearchInput(ctx context.Context, v interface{}) (HotelCriteriaSearchInput, error) {
	var it HotelCriteriaSearchInput
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "checkIn":
			var err error
			it.CheckIn, err = ec.unmarshalNDate2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "checkOut":
			var err error
			it.CheckOut, err = ec.unmarshalNDate2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "hotels":
			var err error
			it.Hotels, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "destinations":
			var err error
			it.Destinations, err = ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "occupancies":
			var err error
			it.Occupancies, err = ec.unmarshalNRoomInput2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐOccupancy(ctx, v)
			if err != nil {
				return it, err
			}
		case "language":
			var err error
			it.Language, err = ec.unmarshalOLanguage2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "currency":
			var err error
			it.Currency, err = ec.unmarshalOCurrency2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "nationality":
			var err error
			it.Nationality, err = ec.unmarshalOCountry2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "market":
			var err error
			it.Market, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHotelSettingsInput(ctx context.Context, v interface{}) (domainHotelCommon.Settings, error) {
	var it domainHotelCommon.Settings
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "context":
			var err error
			it.Context, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "useContext":
			var err error
			it.UseContext, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "connectUser":
			var err error
			it.ConnectUser, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "client":
			var err error
			it.Client, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "group":
			var err error
			it.Group, err = ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "timeout":
			var err error
			it.Timeout, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "auditTransactions":
			var err error
			it.AuditTransactions, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "businessRules":
			var err error
			it.BusinessRules, err = ec.unmarshalOBusinessRulesInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐBusinessRules(ctx, v)
			if err != nil {
				return it, err
			}
		case "suppliers":
			var err error
			it.Suppliers, err = ec.unmarshalOHotelXSupplierInput2ᚖᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSupplier(ctx, v)
			if err != nil {
				return it, err
			}
		case "plugins":
			var err error
			it.Plugins, err = ec.unmarshalOPluginStepInput2ᚖᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPluginStep(ctx, v)
			if err != nil {
				return it, err
			}
		case "testMode":
			var err error
			it.TestMode, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "clientTokens":
			var err error
			it.ClientTokens, err = ec.unmarshalOString2ᚖᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHotelXAccessInput(ctx context.Context, v interface{}) (domainHotelCommon.Access, error) {
	var it domainHotelCommon.Access
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "accessId":
			var err error
			it.AccessId, err = ec.unmarshalNID2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "configuration":
			var err error
			it.Configuration, err = ec.unmarshalOConfigurationInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋaccessᚐAccessConfiguration(ctx, v)
			if err != nil {
				return it, err
			}
		case "settings":
			var err error
			it.Settings, err = ec.unmarshalOSettingsBaseInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSettingsBase(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHotelXFilterPluginTypeInput(ctx context.Context, v interface{}) (domainHotelCommon.FilterPlugin, error) {
	var it domainHotelCommon.FilterPlugin
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "step":
			var err error
			it.Step, err = ec.unmarshalNPluginStepType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPluginStepType(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error
			it.Type, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHotelXFilterSearchInput(ctx context.Context, v interface{}) (search.FilterSearch, error) {
	var it search.FilterSearch
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "access":
			var err error
			it.Access, err = ec.unmarshalOAccessFilterInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋsearchᚐTypeFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "rateRules":
			var err error
			it.RateRules, err = ec.unmarshalORateRulesFilterInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋsearchᚐRateRuleFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "plugin":
			var err error
			it.Plugin, err = ec.unmarshalOHotelXPluginFilterInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐFilterPluginType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHotelXPluginFilterInput(ctx context.Context, v interface{}) (domainHotelCommon.FilterPluginType, error) {
	var it domainHotelCommon.FilterPluginType
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "includes":
			var err error
			it.Includes, err = ec.unmarshalOHotelXFilterPluginTypeInput2ᚖᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐFilterPlugin(ctx, v)
			if err != nil {
				return it, err
			}
		case "excludes":
			var err error
			it.Excludes, err = ec.unmarshalOHotelXFilterPluginTypeInput2ᚖᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐFilterPlugin(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHotelXSupplierInput(ctx context.Context, v interface{}) (domainHotelCommon.Supplier, error) {
	var it domainHotelCommon.Supplier
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "settings":
			var err error
			it.Settings, err = ec.unmarshalOSettingsBaseInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSettingsBase(ctx, v)
			if err != nil {
				return it, err
			}
		case "code":
			var err error
			it.Code, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "accesses":
			var err error
			it.Accesses, err = ec.unmarshalOHotelXAccessInput2ᚖᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐAccess(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputParameterInput(ctx context.Context, v interface{}) (access.Parameter, error) {
	var it access.Parameter
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "key":
			var err error
			it.Key, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error
			it.Value, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPaxInput(ctx context.Context, v interface{}) (domainHotelCommon.Pax, error) {
	var it domainHotelCommon.Pax
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "age":
			var err error
			it.Age, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPluginStepInput(ctx context.Context, v interface{}) (domainHotelCommon.PluginStep, error) {
	var it domainHotelCommon.PluginStep
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "step":
			var err error
			it.Step, err = ec.unmarshalNPluginStepType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPluginStepType(ctx, v)
			if err != nil {
				return it, err
			}
		case "pluginsType":
			var err error
			it.PluginsType, err = ec.unmarshalOPluginsInput2ᚖᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPlugin(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPluginsInput(ctx context.Context, v interface{}) (domainHotelCommon.Plugin, error) {
	var it domainHotelCommon.Plugin
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "type":
			var err error
			it.Type, err = ec.unmarshalNPluginType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐPluginType(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error
			it.Name, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "parameters":
			var err error
			it.Parameters, err = ec.unmarshalOParameterInput2ᚖᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋaccessᚐParameter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRateRulesFilterInput(ctx context.Context, v interface{}) (search.RateRuleFilter, error) {
	var it search.RateRuleFilter
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "includes":
			var err error
			it.Includes, err = ec.unmarshalORateRulesType2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐRateRulesType(ctx, v)
			if err != nil {
				return it, err
			}
		case "excludes":
			var err error
			it.Excludes, err = ec.unmarshalORateRulesType2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐRateRulesType(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRoomInput(ctx context.Context, v interface{}) (domainHotelCommon.Occupancy, error) {
	var it domainHotelCommon.Occupancy
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "paxes":
			var err error
			it.Paxes, err = ec.unmarshalNPaxInput2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPax(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSettingsBaseInput(ctx context.Context, v interface{}) (domainHotelCommon.SettingsBase, error) {
	var it domainHotelCommon.SettingsBase
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "timeout":
			var err error
			it.Timeout, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "auditTransactions":
			var err error
			it.AuditTransactions, err = ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
		case "businessRules":
			var err error
			it.BusinessRules, err = ec.unmarshalOBusinessRulesInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐBusinessRules(ctx, v)
			if err != nil {
				return it, err
			}
		case "currency":
			var err error
			it.Currency, err = ec.unmarshalOCurrency2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUrlsInput(ctx context.Context, v interface{}) (access.Urls, error) {
	var it access.Urls
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "search":
			var err error
			it.Search, err = ec.unmarshalOURI2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "quote":
			var err error
			it.Quote, err = ec.unmarshalOURI2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "book":
			var err error
			it.Book, err = ec.unmarshalOURI2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "generic":
			var err error
			it.Generic, err = ec.unmarshalOURI2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _BookableOptionSearch(ctx context.Context, sel ast.SelectionSet, obj *BookableOptionSearch) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case *domainHotelCommon.Option:
		return ec._HotelOptionSearch(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Priceable(ctx context.Context, sel ast.SelectionSet, obj *Priceable) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case domainHotelCommon.Markup:
		return ec._Markup(ctx, sel, &obj)
	case *domainHotelCommon.Markup:
		return ec._Markup(ctx, sel, obj)
	case domainHotelCommon.Price:
		return ec._Price(ctx, sel, &obj)
	case *domainHotelCommon.Price:
		return ec._Price(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Response(ctx context.Context, sel ast.SelectionSet, obj *Response) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case HotelSearch:
		return ec._HotelSearch(ctx, sel, &obj)
	case *HotelSearch:
		return ec._HotelSearch(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var addOnImplementors = []string{"AddOn"}

func (ec *executionContext) _AddOn(ctx context.Context, sel ast.SelectionSet, obj *AddOn) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, addOnImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddOn")
		case "key":
			out.Values[i] = ec._AddOn_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "value":
			out.Values[i] = ec._AddOn_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var addOnsImplementors = []string{"AddOns"}

func (ec *executionContext) _AddOns(ctx context.Context, sel ast.SelectionSet, obj *AddOns) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, addOnsImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AddOns")
		case "distribute":
			out.Values[i] = ec._AddOns_distribute(ctx, field, obj)
		case "distribution":
			out.Values[i] = ec._AddOns_distribution(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var auditDataImplementors = []string{"AuditData"}

func (ec *executionContext) _AuditData(ctx context.Context, sel ast.SelectionSet, obj *common.AuditData) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, auditDataImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuditData")
		case "transactions":
			out.Values[i] = ec._AuditData_transactions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "timeStamp":
			out.Values[i] = ec._AuditData_timeStamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "processTime":
			out.Values[i] = ec._AuditData_processTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var bedImplementors = []string{"Bed"}

func (ec *executionContext) _Bed(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Bed) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, bedImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Bed")
		case "type":
			out.Values[i] = ec._Bed_type(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Bed_description(ctx, field, obj)
		case "count":
			out.Values[i] = ec._Bed_count(ctx, field, obj)
		case "shared":
			out.Values[i] = ec._Bed_shared(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var cancelPenaltyImplementors = []string{"CancelPenalty"}

func (ec *executionContext) _CancelPenalty(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.CancelPenalty) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, cancelPenaltyImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CancelPenalty")
		case "hoursBefore":
			out.Values[i] = ec._CancelPenalty_hoursBefore(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "penaltyType":
			out.Values[i] = ec._CancelPenalty_penaltyType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "currency":
			out.Values[i] = ec._CancelPenalty_currency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "value":
			out.Values[i] = ec._CancelPenalty_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var cancelPolicyImplementors = []string{"CancelPolicy"}

func (ec *executionContext) _CancelPolicy(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.CancelPolicy) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, cancelPolicyImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CancelPolicy")
		case "refundable":
			out.Values[i] = ec._CancelPolicy_refundable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "cancelPenalties":
			out.Values[i] = ec._CancelPolicy_cancelPenalties(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var criteriaSearchImplementors = []string{"CriteriaSearch"}

func (ec *executionContext) _CriteriaSearch(ctx context.Context, sel ast.SelectionSet, obj *CriteriaSearch) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, criteriaSearchImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CriteriaSearch")
		case "checkIn":
			out.Values[i] = ec._CriteriaSearch_checkIn(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "checkOut":
			out.Values[i] = ec._CriteriaSearch_checkOut(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "hotels":
			out.Values[i] = ec._CriteriaSearch_hotels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "occupancies":
			out.Values[i] = ec._CriteriaSearch_occupancies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "language":
			out.Values[i] = ec._CriteriaSearch_language(ctx, field, obj)
		case "currency":
			out.Values[i] = ec._CriteriaSearch_currency(ctx, field, obj)
		case "nationality":
			out.Values[i] = ec._CriteriaSearch_nationality(ctx, field, obj)
		case "market":
			out.Values[i] = ec._CriteriaSearch_market(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var errorImplementors = []string{"Error"}

func (ec *executionContext) _Error(ctx context.Context, sel ast.SelectionSet, obj *common.AdviseMessage) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, errorImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Error")
		case "code":
			out.Values[i] = ec._Error_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec._Error_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._Error_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var exchangeImplementors = []string{"Exchange"}

func (ec *executionContext) _Exchange(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Exchange) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, exchangeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Exchange")
		case "currency":
			out.Values[i] = ec._Exchange_currency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "rate":
			out.Values[i] = ec._Exchange_rate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var hotelOptionSearchImplementors = []string{"HotelOptionSearch", "BookableOptionSearch"}

func (ec *executionContext) _HotelOptionSearch(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Option) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, hotelOptionSearchImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HotelOptionSearch")
		case "supplierCode":
			out.Values[i] = ec._HotelOptionSearch_supplierCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "accessCode":
			out.Values[i] = ec._HotelOptionSearch_accessCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "market":
			out.Values[i] = ec._HotelOptionSearch_market(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "hotelCode":
			out.Values[i] = ec._HotelOptionSearch_hotelCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "hotelCodeSupplier":
			out.Values[i] = ec._HotelOptionSearch_hotelCodeSupplier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "hotelName":
			out.Values[i] = ec._HotelOptionSearch_hotelName(ctx, field, obj)
		case "boardCode":
			out.Values[i] = ec._HotelOptionSearch_boardCode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "boardCodeSupplier":
			out.Values[i] = ec._HotelOptionSearch_boardCodeSupplier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "paymentType":
			out.Values[i] = ec._HotelOptionSearch_paymentType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._HotelOptionSearch_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "occupancies":
			out.Values[i] = ec._HotelOptionSearch_occupancies(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "rooms":
			out.Values[i] = ec._HotelOptionSearch_rooms(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "price":
			out.Values[i] = ec._HotelOptionSearch_price(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "supplements":
			out.Values[i] = ec._HotelOptionSearch_supplements(ctx, field, obj)
		case "surcharges":
			out.Values[i] = ec._HotelOptionSearch_surcharges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "rateRules":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._HotelOptionSearch_rateRules(ctx, field, obj)
				return res
			})
		case "cancelPolicy":
			out.Values[i] = ec._HotelOptionSearch_cancelPolicy(ctx, field, obj)
		case "remarks":
			out.Values[i] = ec._HotelOptionSearch_remarks(ctx, field, obj)
		case "addOns":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._HotelOptionSearch_addOns(ctx, field, obj)
				return res
			})
		case "token":
			out.Values[i] = ec._HotelOptionSearch_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "id":
			out.Values[i] = ec._HotelOptionSearch_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var hotelSearchImplementors = []string{"HotelSearch", "Response"}

func (ec *executionContext) _HotelSearch(ctx context.Context, sel ast.SelectionSet, obj *HotelSearch) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, hotelSearchImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HotelSearch")
		case "context":
			out.Values[i] = ec._HotelSearch_context(ctx, field, obj)
		case "stats":
			out.Values[i] = ec._HotelSearch_stats(ctx, field, obj)
		case "auditData":
			out.Values[i] = ec._HotelSearch_auditData(ctx, field, obj)
		case "requestCriteria":
			out.Values[i] = ec._HotelSearch_requestCriteria(ctx, field, obj)
		case "options":
			out.Values[i] = ec._HotelSearch_options(ctx, field, obj)
		case "errors":
			out.Values[i] = ec._HotelSearch_errors(ctx, field, obj)
		case "warnings":
			out.Values[i] = ec._HotelSearch_warnings(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var hotelXQueryImplementors = []string{"HotelXQuery"}

func (ec *executionContext) _HotelXQuery(ctx context.Context, sel ast.SelectionSet, obj *HotelXQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, hotelXQueryImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HotelXQuery")
		case "search":
			out.Values[i] = ec._HotelXQuery_search(ctx, field, obj)
		case "searchStatusService":
			out.Values[i] = ec._HotelXQuery_searchStatusService(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var markupImplementors = []string{"Markup", "Priceable"}

func (ec *executionContext) _Markup(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Markup) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, markupImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Markup")
		case "channel":
			out.Values[i] = ec._Markup_channel(ctx, field, obj)
		case "currency":
			out.Values[i] = ec._Markup_currency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "binding":
			out.Values[i] = ec._Markup_binding(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "net":
			out.Values[i] = ec._Markup_net(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "gross":
			out.Values[i] = ec._Markup_gross(ctx, field, obj)
		case "exchange":
			out.Values[i] = ec._Markup_exchange(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "rules":
			out.Values[i] = ec._Markup_rules(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var occupancyImplementors = []string{"Occupancy"}

func (ec *executionContext) _Occupancy(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Occupancy) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, occupancyImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Occupancy")
		case "id":
			out.Values[i] = ec._Occupancy_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "paxes":
			out.Values[i] = ec._Occupancy_paxes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var paxImplementors = []string{"Pax"}

func (ec *executionContext) _Pax(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Pax) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, paxImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Pax")
		case "age":
			out.Values[i] = ec._Pax_age(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var priceImplementors = []string{"Price", "Priceable"}

func (ec *executionContext) _Price(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Price) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, priceImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Price")
		case "currency":
			out.Values[i] = ec._Price_currency(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "binding":
			out.Values[i] = ec._Price_binding(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "net":
			out.Values[i] = ec._Price_net(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "gross":
			out.Values[i] = ec._Price_gross(ctx, field, obj)
		case "exchange":
			out.Values[i] = ec._Price_exchange(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "markups":
			out.Values[i] = ec._Price_markups(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var priceBreakdownImplementors = []string{"PriceBreakdown"}

func (ec *executionContext) _PriceBreakdown(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.PriceBreakDown) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, priceBreakdownImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PriceBreakdown")
		case "effectiveDate":
			out.Values[i] = ec._PriceBreakdown_effectiveDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "expireDate":
			out.Values[i] = ec._PriceBreakdown_expireDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "price":
			out.Values[i] = ec._PriceBreakdown_price(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var promotionImplementors = []string{"Promotion"}

func (ec *executionContext) _Promotion(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Promotion) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, promotionImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Promotion")
		case "code":
			out.Values[i] = ec._Promotion_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Promotion_name(ctx, field, obj)
		case "effectiveDate":
			out.Values[i] = ec._Promotion_effectiveDate(ctx, field, obj)
		case "expireDate":
			out.Values[i] = ec._Promotion_expireDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "hotelX":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hotelX(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var ratePlanImplementors = []string{"RatePlan"}

func (ec *executionContext) _RatePlan(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.RatePlan) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, ratePlanImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RatePlan")
		case "code":
			out.Values[i] = ec._RatePlan_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._RatePlan_name(ctx, field, obj)
		case "effectiveDate":
			out.Values[i] = ec._RatePlan_effectiveDate(ctx, field, obj)
		case "expireDate":
			out.Values[i] = ec._RatePlan_expireDate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var resortImplementors = []string{"Resort"}

func (ec *executionContext) _Resort(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Resort) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resortImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Resort")
		case "code":
			out.Values[i] = ec._Resort_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Resort_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Resort_description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var roomImplementors = []string{"Room"}

func (ec *executionContext) _Room(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Room) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, roomImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Room")
		case "occupancyRefId":
			out.Values[i] = ec._Room_occupancyRefId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "code":
			out.Values[i] = ec._Room_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._Room_description(ctx, field, obj)
		case "refundable":
			out.Values[i] = ec._Room_refundable(ctx, field, obj)
		case "units":
			out.Values[i] = ec._Room_units(ctx, field, obj)
		case "roomPrice":
			out.Values[i] = ec._Room_roomPrice(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "beds":
			out.Values[i] = ec._Room_beds(ctx, field, obj)
		case "ratePlans":
			out.Values[i] = ec._Room_ratePlans(ctx, field, obj)
		case "promotions":
			out.Values[i] = ec._Room_promotions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var roomCriteriaImplementors = []string{"RoomCriteria"}

func (ec *executionContext) _RoomCriteria(ctx context.Context, sel ast.SelectionSet, obj *RoomCriteria) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, roomCriteriaImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoomCriteria")
		case "paxes":
			out.Values[i] = ec._RoomCriteria_paxes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var roomPriceImplementors = []string{"RoomPrice"}

func (ec *executionContext) _RoomPrice(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.RoomPrice) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, roomPriceImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoomPrice")
		case "price":
			out.Values[i] = ec._RoomPrice_price(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "breakdown":
			out.Values[i] = ec._RoomPrice_breakdown(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var ruleImplementors = []string{"Rule"}

func (ec *executionContext) _Rule(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Rule) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, ruleImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Rule")
		case "id":
			out.Values[i] = ec._Rule_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Rule_name(ctx, field, obj)
		case "type":
			out.Values[i] = ec._Rule_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "value":
			out.Values[i] = ec._Rule_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var searchImplementors = []string{"Search"}

func (ec *executionContext) _Search(ctx context.Context, sel ast.SelectionSet, obj *Search) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, searchImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Search")
		case "hotel":
			out.Values[i] = ec._Search_hotel(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var serviceStatusImplementors = []string{"ServiceStatus"}

func (ec *executionContext) _ServiceStatus(ctx context.Context, sel ast.SelectionSet, obj *ServiceStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, serviceStatusImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceStatus")
		case "code":
			out.Values[i] = ec._ServiceStatus_code(ctx, field, obj)
		case "type":
			out.Values[i] = ec._ServiceStatus_type(ctx, field, obj)
		case "description":
			out.Values[i] = ec._ServiceStatus_description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var statImplementors = []string{"Stat"}

func (ec *executionContext) _Stat(ctx context.Context, sel ast.SelectionSet, obj *Stat) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, statImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Stat")
		case "start":
			out.Values[i] = ec._Stat_start(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "end":
			out.Values[i] = ec._Stat_end(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "duration":
			out.Values[i] = ec._Stat_duration(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var statAccessImplementors = []string{"StatAccess"}

func (ec *executionContext) _StatAccess(ctx context.Context, sel ast.SelectionSet, obj *StatAccess) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, statAccessImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatAccess")
		case "name":
			out.Values[i] = ec._StatAccess_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "total":
			out.Values[i] = ec._StatAccess_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "staticConfiguration":
			out.Values[i] = ec._StatAccess_staticConfiguration(ctx, field, obj)
		case "hotels":
			out.Values[i] = ec._StatAccess_hotels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "zones":
			out.Values[i] = ec._StatAccess_zones(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "cities":
			out.Values[i] = ec._StatAccess_cities(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "requestAccess":
			out.Values[i] = ec._StatAccess_requestAccess(ctx, field, obj)
		case "responseAccess":
			out.Values[i] = ec._StatAccess_responseAccess(ctx, field, obj)
		case "transactions":
			out.Values[i] = ec._StatAccess_transactions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "plugins":
			out.Values[i] = ec._StatAccess_plugins(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var statPluginImplementors = []string{"StatPlugin"}

func (ec *executionContext) _StatPlugin(ctx context.Context, sel ast.SelectionSet, obj *StatPlugin) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, statPluginImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatPlugin")
		case "name":
			out.Values[i] = ec._StatPlugin_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "total":
			out.Values[i] = ec._StatPlugin_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var statTransactionImplementors = []string{"StatTransaction"}

func (ec *executionContext) _StatTransaction(ctx context.Context, sel ast.SelectionSet, obj *StatTransaction) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, statTransactionImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatTransaction")
		case "reference":
			out.Values[i] = ec._StatTransaction_reference(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "total":
			out.Values[i] = ec._StatTransaction_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "buildRequest":
			out.Values[i] = ec._StatTransaction_buildRequest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "workerCommunication":
			out.Values[i] = ec._StatTransaction_workerCommunication(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "parseResponse":
			out.Values[i] = ec._StatTransaction_parseResponse(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var statsRequestImplementors = []string{"StatsRequest"}

func (ec *executionContext) _StatsRequest(ctx context.Context, sel ast.SelectionSet, obj *StatsRequest) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, statsRequestImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatsRequest")
		case "total":
			out.Values[i] = ec._StatsRequest_total(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "validation":
			out.Values[i] = ec._StatsRequest_validation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "process":
			out.Values[i] = ec._StatsRequest_process(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "configuration":
			out.Values[i] = ec._StatsRequest_configuration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "request":
			out.Values[i] = ec._StatsRequest_request(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "response":
			out.Values[i] = ec._StatsRequest_response(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "requestPlugin":
			out.Values[i] = ec._StatsRequest_requestPlugin(ctx, field, obj)
		case "responsePlugin":
			out.Values[i] = ec._StatsRequest_responsePlugin(ctx, field, obj)
		case "hotels":
			out.Values[i] = ec._StatsRequest_hotels(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "zones":
			out.Values[i] = ec._StatsRequest_zones(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "cities":
			out.Values[i] = ec._StatsRequest_cities(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "dockerID":
			out.Values[i] = ec._StatsRequest_dockerID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "Accesses":
			out.Values[i] = ec._StatsRequest_Accesses(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var supplementImplementors = []string{"Supplement"}

func (ec *executionContext) _Supplement(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Supplement) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, supplementImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Supplement")
		case "code":
			out.Values[i] = ec._Supplement_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec._Supplement_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Supplement_description(ctx, field, obj)
		case "supplementType":
			out.Values[i] = ec._Supplement_supplementType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "chargeType":
			out.Values[i] = ec._Supplement_chargeType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mandatory":
			out.Values[i] = ec._Supplement_mandatory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "durationType":
			out.Values[i] = ec._Supplement_durationType(ctx, field, obj)
		case "quantity":
			out.Values[i] = ec._Supplement_quantity(ctx, field, obj)
		case "unit":
			out.Values[i] = ec._Supplement_unit(ctx, field, obj)
		case "effectiveDate":
			out.Values[i] = ec._Supplement_effectiveDate(ctx, field, obj)
		case "expireDate":
			out.Values[i] = ec._Supplement_expireDate(ctx, field, obj)
		case "resort":
			out.Values[i] = ec._Supplement_resort(ctx, field, obj)
		case "price":
			out.Values[i] = ec._Supplement_price(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var surchargeImplementors = []string{"Surcharge"}

func (ec *executionContext) _Surcharge(ctx context.Context, sel ast.SelectionSet, obj *domainHotelCommon.Surcharge) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, surchargeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Surcharge")
		case "chargeType":
			out.Values[i] = ec._Surcharge_chargeType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mandatory":
			out.Values[i] = ec._Surcharge_mandatory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "price":
			out.Values[i] = ec._Surcharge_price(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._Surcharge_description(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var transactionsImplementors = []string{"Transactions"}

func (ec *executionContext) _Transactions(ctx context.Context, sel ast.SelectionSet, obj *common.Transactions) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, transactionsImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Transactions")
		case "request":
			out.Values[i] = ec._Transactions_request(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "response":
			out.Values[i] = ec._Transactions_response(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "timeStamp":
			out.Values[i] = ec._Transactions_timeStamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var warningImplementors = []string{"Warning"}

func (ec *executionContext) _Warning(ctx context.Context, sel ast.SelectionSet, obj *common.AdviseMessage) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, warningImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Warning")
		case "code":
			out.Values[i] = ec._Warning_code(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec._Warning_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec._Warning_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	invalid := false
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalid {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAddOn2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐAddOn(ctx context.Context, sel ast.SelectionSet, v AddOn) graphql.Marshaler {
	return ec._AddOn(ctx, sel, &v)
}

func (ec *executionContext) marshalNBed2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐBed(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Bed) graphql.Marshaler {
	return ec._Bed(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) marshalNCancelPenalty2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐCancelPenalty(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.CancelPenalty) graphql.Marshaler {
	return ec._CancelPenalty(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNCancelPenaltyType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐCancelPenaltyType(ctx context.Context, v interface{}) (domainHotelCommon.CancelPenaltyType, error) {
	var res domainHotelCommon.CancelPenaltyType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNCancelPenaltyType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐCancelPenaltyType(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.CancelPenaltyType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNChargeType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐChargeType(ctx context.Context, v interface{}) (domainHotelCommon.ChargeType, error) {
	var res domainHotelCommon.ChargeType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNChargeType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐChargeType(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.ChargeType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNCurrency2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNCurrency2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalNDate2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNDate2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalNDateTime2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNDateTime2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) marshalNError2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋcommonᚐAdviseMessage(ctx context.Context, sel ast.SelectionSet, v common.AdviseMessage) graphql.Marshaler {
	return ec._Error(ctx, sel, &v)
}

func (ec *executionContext) marshalNExchange2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐExchange(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Exchange) graphql.Marshaler {
	return ec._Exchange(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	return graphql.MarshalFloat(v)
}

func (ec *executionContext) unmarshalNHotelXAccessInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐAccess(ctx context.Context, v interface{}) (domainHotelCommon.Access, error) {
	return ec.unmarshalInputHotelXAccessInput(ctx, v)
}

func (ec *executionContext) unmarshalNHotelXFilterPluginTypeInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐFilterPlugin(ctx context.Context, v interface{}) (domainHotelCommon.FilterPlugin, error) {
	return ec.unmarshalInputHotelXFilterPluginTypeInput(ctx, v)
}

func (ec *executionContext) unmarshalNHotelXSupplierInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSupplier(ctx context.Context, v interface{}) (domainHotelCommon.Supplier, error) {
	return ec.unmarshalInputHotelXSupplierInput(ctx, v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalID(v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalNJSON2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNJSON2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) marshalNMarkup2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐMarkup(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Markup) graphql.Marshaler {
	return ec._Markup(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNMarkupRuleType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐMarkupRuleType(ctx context.Context, v interface{}) (domainHotelCommon.MarkupRuleType, error) {
	var res domainHotelCommon.MarkupRuleType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNMarkupRuleType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐMarkupRuleType(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.MarkupRuleType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNOccupancy2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐOccupancy(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Occupancy) graphql.Marshaler {
	return ec._Occupancy(ctx, sel, &v)
}

func (ec *executionContext) marshalNOccupancy2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐOccupancy(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.Occupancy) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOccupancy2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐOccupancy(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNParameterInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋaccessᚐParameter(ctx context.Context, v interface{}) (access.Parameter, error) {
	return ec.unmarshalInputParameterInput(ctx, v)
}

func (ec *executionContext) marshalNPax2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPax(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Pax) graphql.Marshaler {
	return ec._Pax(ctx, sel, &v)
}

func (ec *executionContext) marshalNPax2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPax(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.Pax) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPax2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPax(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNPaxInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPax(ctx context.Context, v interface{}) (domainHotelCommon.Pax, error) {
	return ec.unmarshalInputPaxInput(ctx, v)
}

func (ec *executionContext) unmarshalNPaxInput2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPax(ctx context.Context, v interface{}) ([]domainHotelCommon.Pax, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]domainHotelCommon.Pax, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNPaxInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPax(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNPaymentType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPaymentType(ctx context.Context, v interface{}) (domainHotelCommon.PaymentType, error) {
	var res domainHotelCommon.PaymentType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNPaymentType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPaymentType(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.PaymentType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPluginStepInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPluginStep(ctx context.Context, v interface{}) (domainHotelCommon.PluginStep, error) {
	return ec.unmarshalInputPluginStepInput(ctx, v)
}

func (ec *executionContext) unmarshalNPluginStepType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPluginStepType(ctx context.Context, v interface{}) (domainHotelCommon.PluginStepType, error) {
	var res domainHotelCommon.PluginStepType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNPluginStepType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPluginStepType(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.PluginStepType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPluginType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐPluginType(ctx context.Context, v interface{}) (PluginType, error) {
	var res PluginType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNPluginType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐPluginType(ctx context.Context, sel ast.SelectionSet, v PluginType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPluginsInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPlugin(ctx context.Context, v interface{}) (domainHotelCommon.Plugin, error) {
	return ec.unmarshalInputPluginsInput(ctx, v)
}

func (ec *executionContext) marshalNPrice2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPrice(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Price) graphql.Marshaler {
	return ec._Price(ctx, sel, &v)
}

func (ec *executionContext) marshalNPriceBreakdown2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPriceBreakDown(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.PriceBreakDown) graphql.Marshaler {
	return ec._PriceBreakdown(ctx, sel, &v)
}

func (ec *executionContext) marshalNPromotion2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPromotion(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Promotion) graphql.Marshaler {
	return ec._Promotion(ctx, sel, &v)
}

func (ec *executionContext) marshalNRatePlan2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐRatePlan(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.RatePlan) graphql.Marshaler {
	return ec._RatePlan(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNRateRulesType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐRateRulesType(ctx context.Context, v interface{}) (RateRulesType, error) {
	var res RateRulesType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNRateRulesType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐRateRulesType(ctx context.Context, sel ast.SelectionSet, v RateRulesType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRoom2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐRoom(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Room) graphql.Marshaler {
	return ec._Room(ctx, sel, &v)
}

func (ec *executionContext) marshalNRoom2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐRoom(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.Room) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRoom2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐRoom(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNRoomCriteria2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐRoomCriteria(ctx context.Context, sel ast.SelectionSet, v RoomCriteria) graphql.Marshaler {
	return ec._RoomCriteria(ctx, sel, &v)
}

func (ec *executionContext) marshalNRoomCriteria2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐRoomCriteria(ctx context.Context, sel ast.SelectionSet, v []RoomCriteria) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRoomCriteria2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐRoomCriteria(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNRoomInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐOccupancy(ctx context.Context, v interface{}) (domainHotelCommon.Occupancy, error) {
	return ec.unmarshalInputRoomInput(ctx, v)
}

func (ec *executionContext) unmarshalNRoomInput2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐOccupancy(ctx context.Context, v interface{}) ([]domainHotelCommon.Occupancy, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]domainHotelCommon.Occupancy, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNRoomInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐOccupancy(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNRoomPrice2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐRoomPrice(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.RoomPrice) graphql.Marshaler {
	return ec._RoomPrice(ctx, sel, &v)
}

func (ec *executionContext) marshalNRule2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐRule(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Rule) graphql.Marshaler {
	return ec._Rule(ctx, sel, &v)
}

func (ec *executionContext) marshalNRule2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐRule(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.Rule) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRule2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐRule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNServiceStatus2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐServiceStatus(ctx context.Context, sel ast.SelectionSet, v ServiceStatus) graphql.Marshaler {
	return ec._ServiceStatus(ctx, sel, &v)
}

func (ec *executionContext) marshalNStat2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStat(ctx context.Context, sel ast.SelectionSet, v Stat) graphql.Marshaler {
	return ec._Stat(ctx, sel, &v)
}

func (ec *executionContext) marshalNStatAccess2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatAccess(ctx context.Context, sel ast.SelectionSet, v StatAccess) graphql.Marshaler {
	return ec._StatAccess(ctx, sel, &v)
}

func (ec *executionContext) marshalNStatAccess2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatAccess(ctx context.Context, sel ast.SelectionSet, v []StatAccess) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStatAccess2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatAccess(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNStatPlugin2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatPlugin(ctx context.Context, sel ast.SelectionSet, v StatPlugin) graphql.Marshaler {
	return ec._StatPlugin(ctx, sel, &v)
}

func (ec *executionContext) marshalNStatTransaction2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatTransaction(ctx context.Context, sel ast.SelectionSet, v StatTransaction) graphql.Marshaler {
	return ec._StatTransaction(ctx, sel, &v)
}

func (ec *executionContext) marshalNStatTransaction2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatTransaction(ctx context.Context, sel ast.SelectionSet, v []StatTransaction) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStatTransaction2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatTransaction(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNStatusType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐStatusType(ctx context.Context, v interface{}) (domainHotelCommon.StatusType, error) {
	var res domainHotelCommon.StatusType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNStatusType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐStatusType(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.StatusType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalNString2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalNString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalNString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.marshalNString2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalNSupplementType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSupplementType(ctx context.Context, v interface{}) (domainHotelCommon.SupplementType, error) {
	var res domainHotelCommon.SupplementType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalNSupplementType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSupplementType(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.SupplementType) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNSurcharge2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSurcharge(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Surcharge) graphql.Marshaler {
	return ec._Surcharge(ctx, sel, &v)
}

func (ec *executionContext) marshalNSurcharge2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSurcharge(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.Surcharge) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSurcharge2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSurcharge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalNTransactions2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋcommonᚐTransactions(ctx context.Context, sel ast.SelectionSet, v common.Transactions) graphql.Marshaler {
	return ec._Transactions(ctx, sel, &v)
}

func (ec *executionContext) marshalNTransactions2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋcommonᚐTransactions(ctx context.Context, sel ast.SelectionSet, v []common.Transactions) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTransactions2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋcommonᚐTransactions(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalNUrlsInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋaccessᚐUrls(ctx context.Context, v interface{}) (access.Urls, error) {
	return ec.unmarshalInputUrlsInput(ctx, v)
}

func (ec *executionContext) marshalNWarning2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋcommonᚐAdviseMessage(ctx context.Context, sel ast.SelectionSet, v common.AdviseMessage) graphql.Marshaler {
	return ec._Warning(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !ec.HasError(graphql.GetResolverContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOAccessFilterInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋsearchᚐTypeFilter(ctx context.Context, v interface{}) (search.TypeFilter, error) {
	return ec.unmarshalInputAccessFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalOAccessFilterInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋsearchᚐTypeFilter(ctx context.Context, v interface{}) (*search.TypeFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOAccessFilterInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋsearchᚐTypeFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOAddOn2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐAddOn(ctx context.Context, sel ast.SelectionSet, v []AddOn) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAddOn2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐAddOn(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOAddOns2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐAddOns(ctx context.Context, sel ast.SelectionSet, v AddOns) graphql.Marshaler {
	return ec._AddOns(ctx, sel, &v)
}

func (ec *executionContext) marshalOAddOns2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐAddOns(ctx context.Context, sel ast.SelectionSet, v *AddOns) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AddOns(ctx, sel, v)
}

func (ec *executionContext) marshalOAuditData2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋcommonᚐAuditData(ctx context.Context, sel ast.SelectionSet, v common.AuditData) graphql.Marshaler {
	return ec._AuditData(ctx, sel, &v)
}

func (ec *executionContext) marshalOAuditData2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋcommonᚐAuditData(ctx context.Context, sel ast.SelectionSet, v *common.AuditData) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AuditData(ctx, sel, v)
}

func (ec *executionContext) marshalOBed2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐBed(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.Bed) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBed2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐBed(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	return graphql.UnmarshalBoolean(v)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBoolean2bool(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOBoolean2bool(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOBusinessRulesInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐBusinessRules(ctx context.Context, v interface{}) (domainHotelCommon.BusinessRules, error) {
	return ec.unmarshalInputBusinessRulesInput(ctx, v)
}

func (ec *executionContext) unmarshalOBusinessRulesInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐBusinessRules(ctx context.Context, v interface{}) (*domainHotelCommon.BusinessRules, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBusinessRulesInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐBusinessRules(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOBusinessRulesType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐBusinessRulesType(ctx context.Context, v interface{}) (domainHotelCommon.BusinessRulesType, error) {
	var res domainHotelCommon.BusinessRulesType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOBusinessRulesType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐBusinessRulesType(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.BusinessRulesType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOBusinessRulesType2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐBusinessRulesType(ctx context.Context, v interface{}) (*domainHotelCommon.BusinessRulesType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOBusinessRulesType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐBusinessRulesType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOBusinessRulesType2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐBusinessRulesType(ctx context.Context, sel ast.SelectionSet, v *domainHotelCommon.BusinessRulesType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOCancelPenalty2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐCancelPenalty(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.CancelPenalty) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCancelPenalty2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐCancelPenalty(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCancelPolicy2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐCancelPolicy(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.CancelPolicy) graphql.Marshaler {
	return ec._CancelPolicy(ctx, sel, &v)
}

func (ec *executionContext) marshalOCancelPolicy2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐCancelPolicy(ctx context.Context, sel ast.SelectionSet, v *domainHotelCommon.CancelPolicy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CancelPolicy(ctx, sel, v)
}

func (ec *executionContext) unmarshalOConfigurationInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋaccessᚐAccessConfiguration(ctx context.Context, v interface{}) (access.AccessConfiguration, error) {
	return ec.unmarshalInputConfigurationInput(ctx, v)
}

func (ec *executionContext) unmarshalOConfigurationInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋaccessᚐAccessConfiguration(ctx context.Context, v interface{}) (*access.AccessConfiguration, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOConfigurationInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋaccessᚐAccessConfiguration(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOCountry2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOCountry2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOCountry2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOCountry2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOCountry2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOCountry2string(ctx, sel, *v)
}

func (ec *executionContext) marshalOCriteriaSearch2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐCriteriaSearch(ctx context.Context, sel ast.SelectionSet, v CriteriaSearch) graphql.Marshaler {
	return ec._CriteriaSearch(ctx, sel, &v)
}

func (ec *executionContext) marshalOCriteriaSearch2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐCriteriaSearch(ctx context.Context, sel ast.SelectionSet, v *CriteriaSearch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CriteriaSearch(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCurrency2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOCurrency2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOCurrency2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOCurrency2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOCurrency2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOCurrency2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalODate2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalODate2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalODate2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODate2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalODate2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalODate2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalODurationType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐDurationType(ctx context.Context, v interface{}) (domainHotelCommon.DurationType, error) {
	var res domainHotelCommon.DurationType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalODurationType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐDurationType(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.DurationType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalODurationType2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐDurationType(ctx context.Context, v interface{}) (*domainHotelCommon.DurationType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalODurationType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐDurationType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalODurationType2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐDurationType(ctx context.Context, sel ast.SelectionSet, v *domainHotelCommon.DurationType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOError2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋcommonᚐAdviseMessage(ctx context.Context, sel ast.SelectionSet, v []common.AdviseMessage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNError2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋcommonᚐAdviseMessage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOFilterInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋsearchᚐFilter(ctx context.Context, v interface{}) (search.Filter, error) {
	return ec.unmarshalInputFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalOFilterInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋsearchᚐFilter(ctx context.Context, v interface{}) (*search.Filter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOFilterInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋsearchᚐFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	return graphql.UnmarshalFloat(v)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	return graphql.MarshalFloat(v)
}

func (ec *executionContext) unmarshalOFloat2ᚖfloat64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOFloat2float64(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOFloat2ᚖfloat64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOFloat2float64(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOHotelCriteriaSearchInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐHotelCriteriaSearchInput(ctx context.Context, v interface{}) (HotelCriteriaSearchInput, error) {
	return ec.unmarshalInputHotelCriteriaSearchInput(ctx, v)
}

func (ec *executionContext) unmarshalOHotelCriteriaSearchInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐHotelCriteriaSearchInput(ctx context.Context, v interface{}) (*HotelCriteriaSearchInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOHotelCriteriaSearchInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐHotelCriteriaSearchInput(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOHotelOptionSearch2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐOption(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Option) graphql.Marshaler {
	return ec._HotelOptionSearch(ctx, sel, &v)
}

func (ec *executionContext) marshalOHotelOptionSearch2ᚕᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐOption(ctx context.Context, sel ast.SelectionSet, v []*domainHotelCommon.Option) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOHotelOptionSearch2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐOption(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOHotelOptionSearch2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐOption(ctx context.Context, sel ast.SelectionSet, v *domainHotelCommon.Option) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._HotelOptionSearch(ctx, sel, v)
}

func (ec *executionContext) marshalOHotelSearch2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐHotelSearch(ctx context.Context, sel ast.SelectionSet, v HotelSearch) graphql.Marshaler {
	return ec._HotelSearch(ctx, sel, &v)
}

func (ec *executionContext) marshalOHotelSearch2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐHotelSearch(ctx context.Context, sel ast.SelectionSet, v *HotelSearch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._HotelSearch(ctx, sel, v)
}

func (ec *executionContext) unmarshalOHotelSettingsInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSettings(ctx context.Context, v interface{}) (domainHotelCommon.Settings, error) {
	return ec.unmarshalInputHotelSettingsInput(ctx, v)
}

func (ec *executionContext) unmarshalOHotelSettingsInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSettings(ctx context.Context, v interface{}) (*domainHotelCommon.Settings, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOHotelSettingsInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSettings(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOHotelXAccessInput2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐAccess(ctx context.Context, v interface{}) ([]domainHotelCommon.Access, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]domainHotelCommon.Access, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNHotelXAccessInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐAccess(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOHotelXAccessInput2ᚖᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐAccess(ctx context.Context, v interface{}) (*[]domainHotelCommon.Access, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOHotelXAccessInput2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐAccess(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOHotelXFilterPluginTypeInput2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐFilterPlugin(ctx context.Context, v interface{}) ([]domainHotelCommon.FilterPlugin, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]domainHotelCommon.FilterPlugin, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNHotelXFilterPluginTypeInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐFilterPlugin(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOHotelXFilterPluginTypeInput2ᚖᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐFilterPlugin(ctx context.Context, v interface{}) (*[]domainHotelCommon.FilterPlugin, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOHotelXFilterPluginTypeInput2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐFilterPlugin(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOHotelXPluginFilterInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐFilterPluginType(ctx context.Context, v interface{}) (domainHotelCommon.FilterPluginType, error) {
	return ec.unmarshalInputHotelXPluginFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalOHotelXPluginFilterInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐFilterPluginType(ctx context.Context, v interface{}) (*domainHotelCommon.FilterPluginType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOHotelXPluginFilterInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐFilterPluginType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOHotelXQuery2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐHotelXQuery(ctx context.Context, sel ast.SelectionSet, v HotelXQuery) graphql.Marshaler {
	return ec._HotelXQuery(ctx, sel, &v)
}

func (ec *executionContext) marshalOHotelXQuery2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐHotelXQuery(ctx context.Context, sel ast.SelectionSet, v *HotelXQuery) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._HotelXQuery(ctx, sel, v)
}

func (ec *executionContext) unmarshalOHotelXSupplierInput2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSupplier(ctx context.Context, v interface{}) ([]domainHotelCommon.Supplier, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]domainHotelCommon.Supplier, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNHotelXSupplierInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSupplier(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOHotelXSupplierInput2ᚖᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSupplier(ctx context.Context, v interface{}) (*[]domainHotelCommon.Supplier, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOHotelXSupplierInput2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSupplier(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOID2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalID(v)
}

func (ec *executionContext) marshalOID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalID(v)
}

func (ec *executionContext) unmarshalOID2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNID2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOID2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNID2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOID2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOID2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOID2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOID2ᚖᚕstring(ctx context.Context, v interface{}) (*[]string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOID2ᚕstring(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOID2ᚖᚕstring(ctx context.Context, sel ast.SelectionSet, v *[]string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOID2ᚕstring(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	return graphql.UnmarshalInt(v)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOInt2int(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOInt2int(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOJSON2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOJSON2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOJSON2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOJSON2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOJSON2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOJSON2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOLanguage2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOLanguage2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOLanguage2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOLanguage2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOLanguage2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOLanguage2string(ctx, sel, *v)
}

func (ec *executionContext) marshalOMarkup2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐMarkup(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.Markup) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMarkup2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐMarkup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalOParameterInput2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋaccessᚐParameter(ctx context.Context, v interface{}) ([]access.Parameter, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]access.Parameter, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNParameterInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋaccessᚐParameter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOParameterInput2ᚖᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋaccessᚐParameter(ctx context.Context, v interface{}) (*[]access.Parameter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOParameterInput2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋaccessᚐParameter(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOPluginStepInput2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPluginStep(ctx context.Context, v interface{}) ([]domainHotelCommon.PluginStep, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]domainHotelCommon.PluginStep, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNPluginStepInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPluginStep(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPluginStepInput2ᚖᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPluginStep(ctx context.Context, v interface{}) (*[]domainHotelCommon.PluginStep, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPluginStepInput2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPluginStep(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalOPluginsInput2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPlugin(ctx context.Context, v interface{}) ([]domainHotelCommon.Plugin, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]domainHotelCommon.Plugin, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNPluginsInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPlugin(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOPluginsInput2ᚖᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPlugin(ctx context.Context, v interface{}) (*[]domainHotelCommon.Plugin, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOPluginsInput2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPlugin(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOPrice2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPrice(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Price) graphql.Marshaler {
	return ec._Price(ctx, sel, &v)
}

func (ec *executionContext) marshalOPrice2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPrice(ctx context.Context, sel ast.SelectionSet, v *domainHotelCommon.Price) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Price(ctx, sel, v)
}

func (ec *executionContext) marshalOPriceBreakdown2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPriceBreakDown(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.PriceBreakDown) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPriceBreakdown2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPriceBreakDown(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOPromotion2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPromotion(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.Promotion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPromotion2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐPromotion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalORatePlan2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐRatePlan(ctx context.Context, sel ast.SelectionSet, v []domainHotelCommon.RatePlan) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRatePlan2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐRatePlan(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalORateRulesFilterInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋsearchᚐRateRuleFilter(ctx context.Context, v interface{}) (search.RateRuleFilter, error) {
	return ec.unmarshalInputRateRulesFilterInput(ctx, v)
}

func (ec *executionContext) unmarshalORateRulesFilterInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋsearchᚐRateRuleFilter(ctx context.Context, v interface{}) (*search.RateRuleFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalORateRulesFilterInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋsearchᚐRateRuleFilter(ctx, v)
	return &res, err
}

func (ec *executionContext) unmarshalORateRulesType2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐRateRulesType(ctx context.Context, v interface{}) ([]RateRulesType, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]RateRulesType, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNRateRulesType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐRateRulesType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalORateRulesType2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐRateRulesType(ctx context.Context, sel ast.SelectionSet, v []RateRulesType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRateRulesType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐRateRulesType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOResort2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐResort(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Resort) graphql.Marshaler {
	return ec._Resort(ctx, sel, &v)
}

func (ec *executionContext) marshalOResort2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐResort(ctx context.Context, sel ast.SelectionSet, v *domainHotelCommon.Resort) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Resort(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSettingsBaseInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSettingsBase(ctx context.Context, v interface{}) (domainHotelCommon.SettingsBase, error) {
	return ec.unmarshalInputSettingsBaseInput(ctx, v)
}

func (ec *executionContext) unmarshalOSettingsBaseInput2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSettingsBase(ctx context.Context, v interface{}) (*domainHotelCommon.SettingsBase, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOSettingsBaseInput2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSettingsBase(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOStat2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStat(ctx context.Context, sel ast.SelectionSet, v Stat) graphql.Marshaler {
	return ec._Stat(ctx, sel, &v)
}

func (ec *executionContext) marshalOStat2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStat(ctx context.Context, sel ast.SelectionSet, v *Stat) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Stat(ctx, sel, v)
}

func (ec *executionContext) marshalOStatPlugin2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatPlugin(ctx context.Context, sel ast.SelectionSet, v StatPlugin) graphql.Marshaler {
	return ec._StatPlugin(ctx, sel, &v)
}

func (ec *executionContext) marshalOStatPlugin2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatPlugin(ctx context.Context, sel ast.SelectionSet, v []StatPlugin) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStatPlugin2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatPlugin(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOStatPlugin2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatPlugin(ctx context.Context, sel ast.SelectionSet, v *StatPlugin) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StatPlugin(ctx, sel, v)
}

func (ec *executionContext) marshalOStatsRequest2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatsRequest(ctx context.Context, sel ast.SelectionSet, v StatsRequest) graphql.Marshaler {
	return ec._StatsRequest(ctx, sel, &v)
}

func (ec *executionContext) marshalOStatsRequest2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋpresenterᚋgqlgensmᚐStatsRequest(ctx context.Context, sel ast.SelectionSet, v *StatsRequest) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StatsRequest(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOString2ᚖᚕstring(ctx context.Context, v interface{}) (*[]string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOString2ᚕstring(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOString2ᚖᚕstring(ctx context.Context, sel ast.SelectionSet, v *[]string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOString2ᚕstring(ctx, sel, *v)
}

func (ec *executionContext) marshalOSupplement2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSupplement(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.Supplement) graphql.Marshaler {
	return ec._Supplement(ctx, sel, &v)
}

func (ec *executionContext) marshalOSupplement2ᚕᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSupplement(ctx context.Context, sel ast.SelectionSet, v []*domainHotelCommon.Supplement) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSupplement2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSupplement(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOSupplement2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐSupplement(ctx context.Context, sel ast.SelectionSet, v *domainHotelCommon.Supplement) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Supplement(ctx, sel, v)
}

func (ec *executionContext) unmarshalOURI2string(ctx context.Context, v interface{}) (string, error) {
	return graphql.UnmarshalString(v)
}

func (ec *executionContext) marshalOURI2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOURI2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOURI2string(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOURI2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.marshalOURI2string(ctx, sel, *v)
}

func (ec *executionContext) unmarshalOUnitTimeType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐUnitTimeType(ctx context.Context, v interface{}) (domainHotelCommon.UnitTimeType, error) {
	var res domainHotelCommon.UnitTimeType
	return res, res.UnmarshalGQL(v)
}

func (ec *executionContext) marshalOUnitTimeType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐUnitTimeType(ctx context.Context, sel ast.SelectionSet, v domainHotelCommon.UnitTimeType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOUnitTimeType2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐUnitTimeType(ctx context.Context, v interface{}) (*domainHotelCommon.UnitTimeType, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalOUnitTimeType2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐUnitTimeType(ctx, v)
	return &res, err
}

func (ec *executionContext) marshalOUnitTimeType2ᚖgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋdomainHotelCommonᚐUnitTimeType(ctx context.Context, sel ast.SelectionSet, v *domainHotelCommon.UnitTimeType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOWarning2ᚕgithubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋcommonᚐAdviseMessage(ctx context.Context, sel ast.SelectionSet, v []common.AdviseMessage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWarning2githubᚗcomᚋtravelgateXᚋpresentersᚑbenchmarkᚋpkgᚋcommonᚐAdviseMessage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v introspection.Schema) graphql.Marshaler {
	return ec.___Schema(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		rctx := &graphql.ResolverContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithResolverContext(ctx, rctx)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
